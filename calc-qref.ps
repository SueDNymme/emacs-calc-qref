%!PS

% Library routines

/in { 72 mul } bind def
/mm { 2.83464566929 mul } bind def

%--->     --   landscape   --
% Puts the printer into landscape mode.
/landscape
{
    90 rotate
     0 -8.5 in translate
} bind def

%-->     --   cur-fs   num
% Returns the vertical point-size of the current font.
/cur-fs
{
    currentfont /FontMatrix get
    3 get 1000 mul
} bind def

%--->     /new_name  [array]  /font_name   ReEncodeFont   --
% font_name is a font to be reencoded.
% array is a set of offsets and character names to be encoded.
% new_name is the name to call the font.
%
% Example: /MyFont [8#201 /eacute] /Times-Roman ReEncodeFont
%          /MyFont findfont
%
% This routine was copied somewhat from:
%          _Understanding Postscript_, 3ed, David A. Holzgang.
/ReEncodeFont
{
    1 dict begin    % for temp variable /NewFontDict

    findfont              % Look up the old font
    dup maxlength dict    % Make new font dictionary (same size as old one)
    exch  % forall key/value pairs in old font
    {
	1 index  /FID eq     % Don't copy the /FID entry
	{
	    pop pop
	}
	% else
	{
	    1 index /Encoding eq  % Do a deep copy of the encoding vector
	    {
		dup length array copy    % make the copy
	    } if

	    2 index 3 1 roll put     % put it in the new dictionary
	} ifelse

    } forall

    /NewFontDict exch def    % save the font dict for later manipulation
    NewFontDict /FontName 3 index put   % Give the font its name
    aload   % run through the user's encoding modifications
    length 2 idiv
    {
	NewFontDict /Encoding get
	3 1 roll put
    } repeat

    NewFontDict definefont pop
    end
} def

% Encoding array for this document
/calc-codes
[
    8#300  /ellipsis
    8#301  /quoteleft
    8#302  /quotedblleft
    8#303  /quoteright
    8#304  /quotedblright
    8#305  /endash
    8#306  /emdash

    8#310  /divide
    8#311  /multiply
    8#312  /onequarter
    8#313  /onehalf
    8#314  /threequarters
    8#315  /infinity
    8#316  /theta
    8#317  /pi

    8#320  /minute
    8#321  /second
    8#322  /twosuperior
    8#323  /nsuperior
    8#324  /arrowleft
    8#325  /arrowright
    8#326  /arrowdblleft
    8#327  /arrowdblright

    8#331  /ff
    8#332  /fi
    8#333  /fl
    8#334  /ffi
    8#335  /ffl

    8#340  /fraction
    8#341  /minus
    8#342  /sigma
    8#343  /plusminus
] def

/TB  calc-codes /Palatino-Bold   ReEncodeFont
/TR  calc-codes /Palatino-Roman  ReEncodeFont
/TI  calc-codes /Palatino-Italic ReEncodeFont
/ARG calc-codes /Univers-Condensed-MediumItalic ReEncodeFont

% ----------------------------------------------------------------
% Constants
% ----------------------------------------------------------------
landscape
/paper-h     8.5 in def
/paper-w    11   in def
/top-marg    0.9 in def
/left-marg   0.7 in def
/right-marg  0.7 in def
/bot-marg    0.8 in def
/num-cols    2      def
/gutter-w    0.7 in def
/page-w paper-w left-marg sub right-marg sub def
/page-h paper-h top-marg  sub bot-marg   sub def
/col-w  page-w  num-cols 1 sub gutter-w mul sub   num-cols div  def
/left-x     left-marg              def
/right-x    left-x col-w add def
/bot-y      bot-marg               def
/top-y      paper-h top-marg sub   def
/page-w     right-x left-x sub     def
/page-h     top-y   bot-y sub      def
/init-y     top-y                  def
/heading-x  left-x                 def
/keycol-x   left-x                 def
/text-x     keycol-x 1 in add      def
/arg-x      text-x 0.5 in add      def  % argument-modifier condition
/argtext-x  arg-x 0.5 in add       def  % argument explanation
/cur-col     0      def   % columns are numbered 0 to n-1
/cur-page    1      def   % pages are numbered from 1
/col-xs        % column x-positions
    [
    left-marg
    0 1 num-cols { pop dup col-w add gutter-w add } for
    ] def

/eoc        % end of column
{
    gsave 1 setlinewidth newpath
    left-x bot-y moveto
    right-x bot-y lineto
    right-x top-y lineto
    left-x top-y lineto closepath stroke
    grestore
    
    /cur-col cur-col 1 add def        % increment column number
    cur-col num-cols ge { eop } if    % go to next page?
    /cur-y top-y def                  % at top of column
    /left-x col-xs cur-col get def    % adjust left-x for column
    /right-x left-x col-w add def
    left-x cur-y moveto
} bind def

/eop        % end of page
{
    sp
    /cur-page cur-page 1 add def
    /cur-col 0 def
    /cur-y top-y def
    /left-x left-marg def
    left-x cur-y moveto
} bind def


% ----------------------------------------------------------------
% Global status variables
/cur-y      init-y                 def
/nl-pend?   false                  def  % true if newline is pending

% FONTS


% There are various types of text we will be printing
%        k  key sequences
%        d  descriptive text
%        v  variable names
%        c  comments and asides
% And there are various places we will use these types of text
%        hc heading location
%        kc key-sequence column
%        dc description column
%        pa prefix-argument column
%        pd prefix action description column


% The current text-type and current text-locale are stored in global variables
/cur-ttype /nil  def
/cur-tloc  /nil  def

/locales 4 dict def
locales begin
    % Section headings
    /hc 5 dict def    hc begin
        /ds 14 def
        /d  /TB findfont ds scalefont def
        /sa 6 def    % space above line
        /sb 3 def    % space below line
        /xp 0 def
        end

    % Key-sequence column
    /kc 5 dict def    kc begin
        /ks 10 def
        /k  /Helvetica-Bold findfont ks scalefont def
        /vs ks def
        /v  /TI findfont vs scalefont def
        /cs 8 def
        /c  /TI findfont cs scalefont def
        /xp 0 def
        end

    % Descriptive-text column
    /dc 5 dict def    dc begin
        /ks   kc /ks get  def   % same font size as in kc area
        /k  /LetterGothic-Italic findfont ks scalefont def
        /ds   kc /ks get  def
        /d  /TR findfont ds scalefont def
        /vs   kc /vs get  def
        /v    kc /v  get  def
        /cs   kc /cs get  def
        /c    kc /c  get  def
        /xp 1 in def
        end

    % For prefix-argument conditional area
    /pa 5 dict def    pa begin
        /ds 8 def
        /d  /ARG findfont ds scalefont def
        /cs 6 def
        /c  /TI findfont cs scalefont def
        /xp 0.8 in def
        end
    /pd 5 dict def    pd begin
        /ks  pa /ds get def
        /k /Courier-Bold findfont ks scalefont def
        /ds ks def
        /d  /TR findfont ds scalefont def
        /vs ks def
        /v  /TI findfont vs scalefont def
        /cs ks 0.9 mul def
        /c  /TI findfont vs scalefont def
        /xp 1.3 in  def
        end

end


% /loc set-locale --
/set-locale
{
    dup cur-tloc eq
    {
        pop   % already there
    }
    {
        % locales is a dictionary of  loc-symbol => type-dictionary
        dup /cur-tloc exch def
        locales exch get          % TODO: what if symbol not found?
        /cur-locale exch def
        /cur-ttype /nil def
    } ifelse

    cur-locale /xp get left-x add   % x-position of column
    cur-y moveto
} bind def

% /type set-type --
/set-type
{
    dup cur-ttype eq
    {
        pop
    }
    {
        % cur-fonts is dictionary of  type-symbol => font
        dup /cur-ttype exch def
        cur-locale exch get          % TODO: what if symbol not found?
        setfont
    } ifelse
    down?
} bind def


% Go places
/hc {/hc set-locale} bind def
/kc {/kc set-locale} bind def
/dc {/dc set-locale} bind def
/pa {/pa set-locale} bind def
/pd {/pd set-locale} bind def

% Show things
/k { /k set-type  show} bind def
/v { /v set-type  show} bind def
/d { /d set-type  show} bind def
/c { /c set-type  show} bind def

% heading is a little different
/h
{
    hc  % set heading locale
    % space above heading
    cur-locale begin   sb  d  ds  sa   end
    space-before-line  % sa
    downby             % ds
    setfont            % d
    exch show          % arg to this function
    downby             % sb
    nl
} bind def


% move current Y down by specified amount
/downby
{
    % too close to bottom?
    dup bot-y add cur-y gt {eoc} if

    /cur-y exch neg cur-y add def

    cur-locale /xp get left-x add  cur-y moveto
} bind def

% move current Y down by current font size
/down?
{
    nl-pend? {cur-fs downby} if
    /nl-pend? false def
} bind def


% for debugging/testing/etc
/sp
{
%   0 setlinewidth

    % newpath
    % left-x  bot-y moveto
    % right-x bot-y lineto
    % right-x top-y lineto
    % left-x  top-y lineto
    % closepath stroke

    showpage
    landscape
} def


% Positioning
/newpage
{
    sp
    /cur-y init-y def
    left-x cur-y moveto
} def

% Signal that the next text to be shown has to move current Y down
/nl { /nl-pend? true def } def


% allow for space before a line -- but not at top of page
% immediate -- does not matter if newline pending
/space-before-line
{
    % do nothing if at top of page
    cur-y init-y eq
    {pop}
    {
        dup

        % too close to bottom?
        bot-y add cur-y gt
        {pop eoc}
        {/cur-y exch cur-y exch sub def}
        ifelse
    } ifelse
} bind def


/save-x { /temp-x currentpoint pop def } bind def
/at-x   { temp-x  currentpoint exch pop moveto } bind def

/supscr
{
    gsave
        /TI  cur-fs  0.7 mul  selectfont
        0    cur-fs  0.4 mul  rmoveto show
        currentpoint pop   % current x
    grestore
    currentpoint exch pop   % current-x, previous-y
    moveto
} def

/subscr
{
    gsave
        /TI  cur-fs  0.7 mul  selectfont
        0    cur-fs -0.3 mul  rmoveto show
        currentpoint pop   % current x
    grestore
    currentpoint exch pop   % current-x, previous-y
    moveto
} def


/vx { (x)v } bind def
/vy { (y)v } bind def
/vn { (n)v } bind def


% ----------------------------------------------------------------
% Here we go

% ================
(Data Entry)h
kc vn ( : )k ( d)v                           dc (Fraction: )d vn  ( is numerator, )d (d)v ( is denominator.)d  nl
kc (\()k (real )v (,)k ( imag)v (\))k          dc (Complex (rectangular))d                                         nl
kc (\()k (r )v (;)k ( \316)v   (\))k           dc (Complex (polar))d                                               nl
kc ([)k (a )v (,)k ( b )v (,)k ( \300 )v (])k  dc (Vector)d                                                        nl
% kc ([[)k (a )v (,)k ( b )v (,)k ( \300 )v (],)k ( \300 )v (])k  dc (Matrix)d                                                        nl
kc (")k (hello)v (")k                          dc (String \306 vector of ASCII codes)d                             nl
kc (16 )v (h)k ( 40 )v (m)k ( 20 )v (s)k       dc (HMS form (hour, minute, second))d                               nl
kc (16 )v (@)k ( 40 )v (')k ( 20 )v (")k       dc (HMS form (degree, minute, second))d                             nl
kc (16 )v (o)k ( 40 )v (')k ( 20 )v (")k       dc (HMS form (o \327 degree))d                                      nl
kc ('<)k ( date )v (>)k                        dc (Date form)d                                                     nl
kc (base )v (#)k ( number)v                    dc (Enter number in arbitrary radix; e.g. )d (16#09AB)k (.)d        nl

% Hack!
% from this point on, we don't need such a wide first column.
locales /dc get  dup /xp get 27 sub /xp exch put
% End hack!

% ================
(Stack Operations)h
kc (RET)k      dc (Duplicate )d vx                                                nl
    pa (n > 0)d  pd (duplicate )d vn ( stack items)d                              nl
    pa (n < 0)d  pd (copy the )d (nth)v ( stack item)d                              nl
    pa (n = 0)d  pd (duplicate entire stack)d                                       nl
kc (DEL)k      dc (Delete (pop) )d vx                                             nl
    pa (n > 0)d  pd (delete )d vn ( stack items)d                                 nl
    pa (n < 0)d  pd (delete )d (nth)v ( stack item)d                                nl
    pa (n = 0)d  pd (clear entire stack)d                                           nl
kc (TAB)k      dc (Swap )d vx ( & )d vy                                         nl
    pa (n > 0)d  pd (move )d vx ( to position )d vn (, rotate items downward)d  nl
    pa (n < 0)d  pd (rotate entire stack downward )d vn ( times)d                 nl
    pa (n = 0)d  pd (reverse entires stack)d                                        nl
kc (M-TAB)k    dc (Same as )d (TAB)k (, but rotates UPWARD)d                        nl

5 downby
kc (`)k        dc ((backtick))c ( Edit top of stack. )d (C-c C-c)k ( to return)d  nl
kc (d [)k      dc (Move stack pointer up)d
    18 0 rmoveto (\306 )d save-x (\302freezes\304 part of the stack)c             nl
kc (d ])k      dc (Move stack pointer down)d at-x (as a place to hold values)c    nl

kc (M-3 m g)k  dc (Current stack size)d                                           nl
kc (~)k        dc (Pop top-of-stack, and use it as a prefix for next command)d    nl
kc (K)k        dc (Peform next operation, but keep arguments on stack)d           nl
kc (M-RET)k    dc (Push arguments to last operation back onto stack)d             nl

% ================
(Rounding) h
kc (R)k    dc (Round to nearest integer)d                                nl
kc (I R)k  dc (Truncate to integer (round towards zero) )d ((Also truncates dates))c                nl
kc (F)k    dc (Floor: truncate toward \341\315)d nl
kc (1 %)k  dc (Fractional part of )d vx                                nl


% ================
(Random numbers)h
kc (k r)k dc (Random number between 0 and )d vx nl
          dc (Result will be integer or float depending on )c vx (\303s type)c nl
        pa (with arg)c pd (Use argument instead of top-of-stack)d nl
kc (k a)k dc (Random-again: make another with same parameters)d nl

eoc

% ================
(Modes)h
kc (I)k    dc (Note: )c (I)k ( prefix before any display mode affects only the top-of-stack,)c nl
           dc (and only temporarily. Handy for base conversions!)c nl
kc (p)k    dc (Precision)d                                nl
kc (m r)k  dc (Radians)d                                  nl
kc (m d)k  dc (Degrees )d   ((default))c                  nl
4 downby
kc (d 2)k  dc (Display in )d   save-x (binary)d            nl
kc (d 8)k  dc                  at-x   (octal)d             nl
kc (d 0)k  dc                  at-x   (decimal)d           nl
kc (d 6)k  dc                  at-x   (hexadecimal)d       nl
kc (d r)k  dc ((with prefix))c at-x   (arbitrary radix from 2\30536)d  nl
4 downby
kc (d f)k  dc (Fixed-point display )d                     nl
kc (d n)k  dc (Floating-point )d ((normal))c ( display)d  nl
kc (d s)k  dc (Scientific notation )d                     nl
kc (d e)k  dc (Engineering notation )d                    nl
4 downby
kc (d l)k  dc (Line numbers on/off )d ((useful before copy/kill))c nl
kc (d o)k  dc (Fraction display. Enter one or two characters)d nl
           dc (One char \(e.g. )c (:)k (\) for improper fraction display: )c (51:8)k nl
           dc (Two chars \(e.g. )c (+/)k (\) for mixed-fraction display: )c  (6+3/8)k nl

% ================
(Stack Trail)h
kc (t i)k  dc (Go into trail)d                                  nl
kc (t o)k  dc (Go out of trail)d                                 nl
kc (t d)k  dc (Toggle trail display)d                            nl
        pa (n = 0)d  pd (turn trail display off)d                  nl
        pa (n = 1)d  pd (turn it on)d                              nl
4 downby
kc (t p)k  dc (Move to previous trail entry)d                    nl
kc (t n)k  dc (Move to next trail entry)d                        nl
kc (t y)k  dc (Yank current trail entry to stack)d               nl
kc (t [)k  dc (Move to first trail entry)d                       nl
kc (t ])k  dc (Move to last trail entry)d                        nl
kc (t b)k  dc (Move back one screen)d                            nl
kc (t f)k  dc (Move forward one screen)d                         nl
kc (t h)k  dc (Move trail pointer HERE to cursor position)d      nl
4 downby 
kc (t m)k  dc (Mark \306 enter a string to be used as a label)d  nl
kc (t s)k  dc (Search forward in trail)d                         nl
kc (t r)k  dc (Search backward in trail)d                        nl
kc (t k)k  dc (Kill the current trail line)d                     nl

% ================
(Percentages)h
kc (M-%)k    dc (Converts )d vx ( to percentage: 8 \325 8%)d        nl
kc (c %)k    dc (Converts decimal to percent: 0.08 \325 8%)d      nl
kc (M-% *)k  dc (Calculate )d vx (% of )d vy                  nl
kc (/ c %)k  dc (Calculates what percent )d vx ( is of )d vy  nl
kc (b %)k    dc (Percent change from )d vy ( to )d vx         nl

% ================
(Binary)h
kc (b c)k  dc (\302Clip\304 to current word size)d                         nl
        pa (n)d pd (word size )d ((default: 32))c                          nl
kc (b a)k  dc (Bitwise AND)d                                               nl
kc (b o)k  dc (Bitwise OR)d                                                nl
kc (b x)k  dc (Bitwise XOR)d                                               nl
kc (b n)k  dc (Bitwise NOT)d                                               nl
kc (b u)k  dc (Unpack binary number into vector of bit position numbers)d  nl
kc (b p)k  dc (Pack such a vector into a binary number)d                   nl
kc (there are also a ton of shift & rotate operations)c                    nl

% ================
(Killing, Copying, Yanking)h
kc (C-k)k      dc (kill stack item at cursor)d                                        nl
kc (M-k)k      dc (copy stack item at cursor to kill ring)d                           nl
kc (C-w)k      dc (kill stack items between mark & point)d                            nl
kc (M-w)k      dc (copy stack items between mark & point)d                            nl
    pa (n > 0)d    pd (copy/kill )d vn ( lines starting at the current stack position)d       nl
    pa (n < 0)d    pd (copy/kill )d vn ( lines above the current stack position)d             nl
kc (C-y)k      dc (yank from kill ring)d                                              nl
kc (C-x * g)k  dc (parse region in current buffer, into vector of values)d            nl
    pa (n = 0)d    pd (grabs current line)d                                             nl
    pa (n > 0)d    pd (grabs from point to )d vn ( lines forward)d                            nl
kc (C-x * r)k  dc (parses region in current buffer as (matrix) rectangle of values)d  nl
    pd (matrix will have only 1 column)d           pa (with arg)c                             nl
kc (C-x * :)k  dc (grab a rectangle of numbers in columns, sum them)d                 nl
kc (C-x * _)k  dc (grab a rectangle of numbers in rows, sum them)d                    nl
kc (y)k       dc (copies top of stack into most-recently-used buffer)d               nl
kc (C-x * y)k  dc (copies top of stack HERE)d                                         nl

% ================
(General math)h
kc (Q)k      dc (Square root)d         nl
kc (&)k      dc (Inverse: 1/)d vx    nl
kc (L)k      dc (Natural logarithm)d   nl
kc (E)k      dc (e)d   (x) supscr      nl
kc (I L)k    dc (also e)d  (x) supscr  nl
kc (H L)k    dc (Common logarithm)d    nl
2 downby
kc (I H L)k  dc (10)d   (x) supscr                         nl
kc (B)k      dc (log)d    (x) subscr   (\()d vy (\))d    nl
kc (=)k      dc (Evaluate )d ((formula, variable, etc.))c  nl
             dc (predefined variables: )d (e)c (, )d
                                    (pi)c (, )d
                                    (i)c (, )d
                                    (phi)c (, )d
                                    (gamma)c (, )d
                                    (inf)c (, )d
                                    (nan)c                 nl
kc (^)k    dc (Power: )d vy (x) supscr      nl
kc (I ^)k  dc (Root: )d vy (1\340x) supscr  nl
kc (\\)k   dc (Integer division)d          nl
kc (:)k    dc (Fraction division)d         nl
kc (%)k    dc (Modulo)d                    nl
4 downby
kc (A)k     dc (|)d vx (| \306 absolute value (or complex magnitude))d  nl
eoc (General math, cont'd)h
kc (f s)k    dc (Sign operator, returns \3411, 0, or 1)d                        nl
kc (f h)k    dc (Hypotenuse operation: sqrt\()d vx (\322 + )d vy (\322\))d  nl
kc (f n)k    dc (Minimum of )d vx ( and )d vy                               nl
kc (f x)k    dc (Maximum of )d vx ( and )d vy                               nl
kc (f [)k    dc (Decrement )d vx                                              nl
kc (f ])k    dc (Increment )d vx                                              nl
4 downby
kc (k g)k    dc (GCD of two integers or fractions)d      nl
kc (k l)k    dc (LCM of two integers or fractions)d      nl
kc (!)k     dc (Factorial or gamma)d                    nl
kc (k c)k    dc (Combinations: )d vy (-choose-)d vx  nl
kc (H k c)k dc (Permutations: )d vy (-permute-)d vx nl
kc (k f)k   dc (Calculate prime factors of )d vx nl
kc (k p)k   dc (Check whether top-of-stack number is prime)d nl
kc (k n)k   dc (Calculate next prime number larger than)d vx nl
kc (I k n)k   dc (Calculate prime number smaller than)d vx nl

% ================
(Date/Time operations)h
kc (t N)k  dc (Push current date/time onto stack)d                             nl
kc (t N F)k dc (Current date only)d nl
kc (t U)k  dc (Convert date to/from Unix epoch seconds)d                       nl
kc (t D)k  dc (Convert date to/from julian number)d                            nl
kc (t P)k  dc (Extract date/time component:)d nl
        pa (n = 1,2,3)d pd (  year, month, or day)d nl
        pa (n = 4,5,6)d pd (  hour, minute, or second)d nl
        pa (n = 7)d pd (  weekday : 0=Sunday \325 6=Saturday)d nl
        pa (n = 8)d pd (  day-of-year)d nl
        pa (n = 9)d pd (  time, as HMS form)d nl
kc (v p)k  dc (Pack stack elements into a date or time:)d                      nl
        pa (n =  \3413)d  pd (Make a time (HMS) from top three stack elements)d  nl
        pa (n = \34114)d  pd (Make a date (YMD) from top three stack elements)d  nl
        pa (n = \34115)d  pd (Make a date/time from top six stack elements)d     nl
kc (I R)k  dc (Truncate date )d ((remove time portion))c nl
kc (t M)k  dc (Change day-of-month. With no arg, becomes 1st day of month)d nl
        pa (n = 0)d pd (last day of month)d nl
        pa (n)d     pd (nth day of month)d nl
kc (t Y)k  dc (Change day-of-year. With no arg, becomes 1st day of year)d nl
        pa (n = 0)d pd (last day of year)d nl
        pa (n < 0)d pd (1st day of nth month)d nl
        pa (n > 0)d pd (nth day of the year)d nl
kc (t W)k dc (Change day of week. With no arg, Sunday on or before )d vx nl
        pa (n)d pd (specified day-of-week on or before top-of-stack)d nl
kc (t I)k dc (Add 1 month to date)d nl
        pa (n)d pd (add n months to date)d nl
kc (f [)k dc (Decrement date by 1 day, or datetime by 1 sec)d nl
kc (f ])k dc (Increment date by 1 day, or datetime by 1 sec)d nl
kc (t +)k dc (Add business days)d nl
kc (t -)k dc (Subtract business days)d nl
kc (s H)k dc (Edit business holidays)d nl

% ================
(Trigonometry)h
kc (Note: )c (I)k ( prefix for inverse; )c (H)k ( prefix for hyperbolic)c nl
kc (S)k dc (Sine)d nl
kc (C)k dc (Cosine)d nl
kc (T)k dc (Tangent)d nl
kc (f T)k dc (Two-argument arctangent\()d vy (/)d vx (\))d nl

% ================
(Storing/recalling)h
kc (s s)k dc (Store )d vx ( (prompts for name))c nl
kc (s t)k dc (Store )d vx ( and pop from stack) nl
kc (s r)k dc (Recall variable onto stack)d nl
kc (s x)k dc (Exchange variable with top-of-stack)d nl
kc (s u)k dc (Undefine a variable)d nl
4 downby
kc (s +)k dc (Pop )d vx ( and add: )d      (var)v ( \324 )d (var)v ( + )d    vx   nl
kc (s -)k dc (Pop )d vx ( and subtract: )d (var)v ( \324 )d (var)v ( \341 )d vx   nl
kc (s *)k dc (Pop )d vx ( and multiply: )d (var)v ( \324 )d (var)v ( \311 )d vx   nl
kc (s /)k dc (Pop )d vx ( and divide: )d   (var)v ( \324 )d (var)v ( \310 )d vx   nl
kc (I s -)k dc (Pop )d vx ( and subtract: )d (var)v ( \324 )d vx ( \341 )d (var)v   nl
kc (I s /)k dc (Pop )d vx ( and divide: )d   (var)v ( \324 )d vx ( \310 )d (var)v   nl
4 downby
kc (s n)k dc (Negate the value of a variable)d nl
kc (s &)k dc (Invert the value of a variable)d nl
kc (s [)k dc (Decrement the value of a variable)d nl
kc (s ])k dc (Increment the value of a variable)d nl



eoc sp
