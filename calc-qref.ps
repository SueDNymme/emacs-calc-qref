%!PS

% Rewrite from scratch.
% EJR 11/25/2014

%%% Setup
% (../error.ps) run
(../postscript-utils/basic.ps) run
(../postscript-utils/array.ps) run
(../postscript-utils/cond.ps) run
(../postscript-utils/position.ps) run
(../postscript-utils/ejr-show.ps) run
(../postscript-utils/ISO-Latin-1.ps) run
(../postscript-utils/radical.ps) run
(../postscript-utils/geom.ps) run
(../postscript-utils/sort.ps) run

%%% ---------------------------------------------------------------------------------
%%% Configuration
/ejr? true def
/color false def

/doc-title    (Eric's Gnu Emacs Calc Quick Reference) def
/doc-date     (2015 APR 20) def
/doc-version  (1.01.00) def

/lm 0.75 in def
/rm 0.75 in def
/tm 0.75 in def
/bm 0.75 in def
/Nup 4 def
/Duplex? true def

% Load needed font files
(fonts/ucrb8a.pfa)  run    % Nimbus Mono L Bold
(fonts/uhvro8a.pfa) run    % Nimbus Sans L Regular Italic
(fonts/uhvr8v.pfa)  run    % Vn Nimbus Sans L
(fonts/utmr8a.pfa)  run    % Nimbus Roman No9 L Regular
(fonts/utmri8a.pfa) run    % Nimbus Roman No9 L Regular Italic

% Re-encode fonts as needed:
/Typeface-for-Keystrokes     /NimbusMonL-Bold           def
/Typeface-for-Text           /NimbusRomNo9L-Regu        def
/Typeface-for-Text-Italic    /NimbusRomNo9L-ReguItal    def
/Typeface-for-Greek          /Symbol                    def
/Typeface-for-Prefix-Args    /NimbusSanL-ReguItal       def
/Typeface-for-Math           /Symbol                    def
/Typeface-for-Headings       /Helvetica-Bold            def
/Typeface-for-Page-Headings  /VnNimbusSansL             def
/Typeface-for-Front-Cover    /VnNimbusSansL             def

%%% ---------------------------------------------------------------------------------

(../postscript-utils/page-init.ps) run


% /sws{stringwidth pop}bd
% /rs{dup sws neg 0 RM s}bd
% /cs{dup sws -2 div 0 RM s}bd
% /CX{C pop}bd
% /CY{C exch pop}bd
% /x={C exch pop M}bd
% /x+{C CAB add exch M}bd
% /y={C pop exch M}bd
% /y+{C BCA add M}bd
% /y-{C BCA sub M}bd
% /x=y-{C exch pop exch sub M}bd

% Font setup
/punc-chars  [[(´) /quoteright]    % &''
              [(`) /quoteleft]     % backtick
              [(«) /quotedblleft]  % &<<
              [(») /quotedblright] % &>>
              [(-) /hyphen]        % hyphen
              [(­) /minus]         % &--
              [(¬) /endash]        % &NO
              [(¯) /emdash]        % &'m
              [(Þ) /pi]            % &TH
              [(¨) /ellipsis]      % &':
              [(Ø) /notequal]      % &O/
              [(Î) /fi]            % &I>
              [(Ê) /fl]            % &E>
] def
/math-chars  [[(­) /minus]         % &--
              [(*) /multiply]
              [(/) /divide]
              [(Ø) /notequal]      % &O/
              [(«) /arrowdblleft]  % &<<
              [(») /arrowdblright] % &>>
              [(æ) /infinity]      % &ae
              [([) /arrowleft]
              [(]) /arrowright]
] def
/kbd-chars   [[(`)    /quoteleft]
              [(´)    /quoteright]    % &''
              [(')    /quotesingle]
] def
/greek-chars [[(p)    /pi]
              [(r)    /rho]
              [(ø)    /phi]      % &o/
              [(s)    /sigma]
              [(t)    /theta]
              [(O)    /Omega]
] def


% Font sizes and other spacing
/fsT  12 def  % size for most text
/fsC   9 def  % size for comments
/fsP  10 def  % prefix-arg doco
/fsH  14 def  % headings
/fsN  12 def  % page numbers
/fsF  24 def  % front cover title
/body-small-vs   fsT 2 div def    % A small vertical spacing in between body text lines
/begin-sect-vs   fsT 6 div def    % Vert space after heading, before body text
/end-sect-vs     fsH def         % Vertical spacing at the end of a section


% Load, encode, scale, and store fonts for the document

% FONT CONSIDERATIONS:
%
% The following categories of text are used by this document,
% and they have these font requirements:
%
% HEADING  (/FH)
%     Should be sans-serif (I think), and boldface.
%     No other particular requirements.
%
% KEYSTROKE (/FK, /FKC)
%     Should be monospace.
%     Zero should not be slashed or dotted; should be distinct from O.
%     Backtick and apostrophe should be distinct and symmetric.
%     Should also have straight-quote and straight-double-quote (' and ").
%     Capital/lower pairs (Zz, Ss, Xx) should be distinguishable.
%     The following characters are used, and should look good: [] () <> ^ % & | # _
%
% TEXT (/FT, /FPT)
%     Should be upright serif typeface (I think).
%     Must include the following: endash, emdash, quoteright, quoteleft, quotedblleft, quotedblright,
%                                 hyphen, ellipsis.
%     Should come in a boldface (/FB) and an italic (/FI) version.
%     Ligatures might be nice (fl, fi, Fl, Fi).
%     Would be nice if we could find one with left-arrow, right-arrow, both-arrow.
%
% VARIABLES (/FV, /FVC)
%     Should be an italic serif typeface.
%     Must include the following: endash, emdash, quotedblleft, quotedblright, hyphen, ellipsis,
%                                 multiply, divide.
%     Ligatures might be nice (fl, fi, Fl, Fi).
%
% PREFIX-ARGS (/FPA)
%     Should be oblique sans-serif.
%     Must include the following: minus, notequal
%
% PREFIX-ARG DESCRIPTIVE TEXT (/FPT)
%     Should be italic serif typeface.
%     Pretty much the same requirements as regular text.
%
% MATH SYMBOLS (/FM)
%     Must include the following: pi, sigma, theta, Omega, plusminus, notequal, infinity, minus
%
% COMMENTS (/FC)
%     Should be a smaller, italic version of TEXT (/FT).

% %%%--->  /Font-varname size  /Font-internalname  [overrides]  (filename)  /FontName   setupfont  --
% /setupfont
% {
%     2 index CAB EncodeFont
%     findfont exch scalefont def
% } def


% Re-encode fonts as needed:
/Typeface-for-Keystrokes      kbd-chars    Typeface-for-Keystrokes     EncodeFont
/Typeface-for-Text            punc-chars   Typeface-for-Text           EncodeFont
/Typeface-for-Text-Italic     punc-chars   Typeface-for-Text-Italic    EncodeFont
/Typeface-for-Greek           greek-chars  Typeface-for-Greek          EncodeFont
/Typeface-for-Prefix-Args     punc-chars   Typeface-for-Prefix-Args    EncodeFont
/Typeface-for-Math            math-chars   Typeface-for-Math           EncodeFont
/Typeface-for-Headings        punc-chars   Typeface-for-Headings       EncodeFont
/Typeface-for-Page-Headings   punc-chars   Typeface-for-Page-Headings  EncodeFont
/Typeface-for-Front-Cover     punc-chars   Typeface-for-Front-Cover    EncodeFont

/SF {findfont exch scalefont def}def
/FK  fsT  /Typeface-for-Keystrokes     SF
/FT  fsT  /Typeface-for-Text           SF
/FI  fsT  /Typeface-for-Text-Italic    SF
/FV  fsT  /Typeface-for-Text-Italic    SF
/FG  fsT  /Typeface-for-Greek          SF
/FC  fsT  /Typeface-for-Text-Italic    SF
/FPA fsP  /Typeface-for-Prefix-Args    SF
/FPT fsP  /Typeface-for-Text           SF
/FM  fsT  /Typeface-for-Math           SF
/FH  fsH  /Typeface-for-Headings       SF
/FPN fsN  /Typeface-for-Page-Headings  SF
/FF  fsF  /Typeface-for-Front-Cover    SF


% Superscript/subscript fonts.
% FTS: Text superscript font. For numeric exponents.
% Use this only when numeric superscripts are not available in the base font,
% because these don't look as good. Most fonts have at least ² and ³.
/FTS   FT  [0.6 0 0 0.6   0  fsT 0.3 mul] makefont def
% FVS: Superscript font for (lowercase) variables, e.g. x and y.
/FVS   FV  [0.6 0 0 0.6   1  fsT 0.4 mul] makefont def
% FVs: Subscript font for (lowercase) variables, e.g. x and y.
/FVs   FV  [0.6 0 0 0.6   0  fsT -0.2 mul] makefont def

% Horizontal positions
FK setfont
/xp   lx (I H) s-width add def     % Start of letter prefix
/xk   xp /space s-width add def    % start of command keystroke
/xt   lx (C-x * G    ) s-width add def   % start of text
FPA setfont
/xpa  xt 27 add def                     % Prefix arg
% prefix operator position: centered on equals sign
/xpo  xpa (n )    stringwidth pop add (=) stringwidth pop 2 div add def
/xpv  xpa (n = )  stringwidth pop add def   % prefix value
/xpvr xpv (4,5,6) stringwidth pop add def   % prefix value (right-justified)
/xpvR xpv (­00)   stringwidth pop add def   % prefix value (alt right-justified)
/xpt  xpvr 9 add def                        % prefix text description
/ts   {1 x+} def    % "tiny space" for fake-kerning


% Starting a new line (and similar)
/nl   {lx  fsT  x=y-} def
/nlh  {lx  fsH  x=y-  FH setfont} def   % header
/nlc  {lx  fsC  x=y-  FC setfont} def   % comment (left-margin)
/nlct {xt  fsC  x=y-  FC setfont} def   % comment (text column)
/nlp  {xpa fsP  x=y-  FPA setfont} def
/small-vs {body-small-vs y-} def
/sect-vs  {end-sect-vs y-} def               % vertical space after a section
/nl* {nl Hline} def   % temp for debugging


% Show a heading
/head
{
    % record index entry -- add to front of existing array
    /index-entries
    [
        [ 3 index  page-label ]
        index-entries aload pop
    ] def
    
    nlh show
    begin-sect-vs y-
} def

% Show text in comment style
/com
{
    2 dict begin
    /com-save-m matrix currentmatrix def
    /com-save-f currentfont def
    FI setfont

    fsC fsT div dup scale
    s-show

    com-save-f setfont
    com-save-m setmatrix
    end
} def

% Show text in prefix-documentation style
/pdoc
{
    2 dict begin
    /com-save-m matrix currentmatrix def
    /com-save-f currentfont def
    FT setfont

    fsP fsT div dup scale
    s-show

    com-save-f setfont
    com-save-m setmatrix
    end
} def

% Show a prefix key sequence on the current line.
/pk {FK setfont xp x= s-rshow} def

% Show a prefix chord on the current line
/pc {FK setfont xk x= s-rshow} def

% Show a command key sequence on the current line.
% Note: positions point, and sets font, for subsequent text documentation.
/k  {FK setfont xk x= s-show  xt x= FT setfont}def

% Show a data-entry expression, then position for text description
/data-ent
{
    FK setfont
    lx x=   s-show
    xt x=
    FT setfont
} def

% Describe numeric prefix options
/pfx
{
    FPA  setfont
    xpa  x= (n) show
    xpv  x=     s-show
    FM   setfont
    xpo  x=     s-cshow
    xpt  x=
    FPT  setfont
} def
/pfx-x
{
    FPA  setfont
    xpa  x= (x) show
    xpv  x=     s-show
    FM   setfont
    xpo  x=     s-cshow
    xpt  x=
    FPT  setfont
} def
/pfx-r
{
    FPA  setfont
    xpa  x= (n) show
    xpvr x=     s-rshow
    FM   setfont
    xpo  x=     s-cshow
    xpt  x=
    FPT  setfont
} def
/pfx-any
{
    FPA  setfont
    xpa  x= (any arg) show
    xpt  x=
    FPT  setfont
} def

% Calc command meant to be used from other buffers
/buf-cmd
{
    FK setfont
    lx x= s-show
    xt x=
    FT setfont
} def

% Page numbers and page headings
/end-of-page
{
    page-label () ne
    {
        FPN setfont
        rx ty  moveto   fsN y-
        [(Page ) page-label] s-rshow
    }if

    % Temp for development: outline each page (within margins)
    % 0 setlinewidth
    % lx by moveto rx ty rectto stroke
} def

% Misc shortcuts
/vx [FV(x)] def    % variable "x"
/vy [FV(y)] def    % variable "y"
/vz [FV(z)] def    % variable "z"
/vn [FV(n)] def    % variable "n"
/vnth [FV(nth)] def    % variable "nth"
/ss /s-show load def

% Experiment to show a fraction a/b
% assumes args are lowercase letters
/a-over-b
{
    0   fsT 5 div  rmoveto
    exch s-show

    0    fsT -5 div  rmoveto
    (/) show

    fsT  -8 div  fsT -5 div  rmoveto
    s-show
    0  fsT  5 div   rmoveto
} def

% Storage for temporary x-positions
/tx1 0 def
/tx2 0 def
/tx3 0 def
/tx4 0 def

% Index entries
/index-entries [] def

%%%-------------------------------------------------------------------------------------
% The reference materials are stored in blocks; this makes it easier
% to rearrange (to make them fit on the pages, for example).

/data-entry
{
    (Data Entry) head

    % This section needs a bit more space in the left column
    2 dict begin
    % This one seems to be the longest data-entry expression:
    /complex-rect  [FK (\() [FV( real )] (,) [FV( imag )] (\)  )]  def
    % Redefine text-x position for this section:
    /xt  lx  complex-rect s-width add   def

    nl  [(_) FV(digits)] data-ent
                ((underscore))com  ( Negative sign in data entry)ss
    nl  [[FV(n )] (:) [FV( d)]] data-ent
                [(Fraction: ) vn ( is numerator, ) [FV(d)] ( is denominator)]ss
    nl  complex-rect data-ent
                (Complex (rectangular form))ss
    nl  [(\() [FV( r )] (;) [FG( t )] (\)  )]data-ent
                (Complex (polar form))ss
    nl  [([) [FV( a )] (,) [FV( b )] (,)   [FV( ¨ )] (])] data-ent  (Vector. Nest vectors to make a matrix.)ss
    nl  [(") [FV(hello)] (")] data-ent     (String: vector of ASCII codes)ss
    nl  [[FV(16){ts}](h) [FV( 40){ts}](m)  [FV( 20){ts}](s)]data-ent
                [(HMS form (hour, minute, second))]ss
    nl  [[FV(16){ts}](@) [FV( 40){ts}](')  [FV( 20){ts}](")]data-ent
                [(HMS form (degree, minute, second))]ss
    nl  [[FV(16){ts}](o) [FV( 40){ts}](')  [FV( 20){ts}](")]data-ent
                [(HMS form \() [FK(o)] ( represents «degree»\))]ss
    nl  [(´<) [FV(date)] (>)]data-ent
                [(Date form \(rather Êexible\))]ss
    nl  [[FV(base )] (#) [FV( number)]]data-ent
                [(Use arbitrary radix. Example: ) FK(16#09AB)]ss
    nl  [[FV(mean )] (p) [FG( s )]]data-ent
                [(Error form: ) FV(mean ) FM /plusminus FV( std dev)]ss
    nl  [[FV(num )] (M) [FV( modulus)]]data-ent
                [(Modulo form.)]ss
    nl  [([)  [FV( num )] (..) [FV( num )]  (])]data-ent   (Closed interval)ss
    nl  [(\() [FV( num )] (..) [FV( num )] (\))]data-ent   (Open interval  )ss
            [(\(Mixed-intervals ¯ ) [FK(\(..])] ( or ) [FK([..\))] ( ¯ are also allowed)]com
    nl  (´)data-ent        ((apostrophe))com [{/tx1 CX store}( Enter expression in algebraic mode)]ss
    nl  (`)data-ent        ((backtick))com   [{tx1 x=}       ( Edit top of stack. ) [FK(C-c C-c)] ( to return)]ss

    end
    sect-vs
} def

/stack-ops
{
    (Stack Operations) head

    nl      (RET)k     [(Duplicate ) vx]ss
    nlp  (=) (0) pfx   (duplicate entire stack)pdoc
    nlp  (>) (0) pfx   [(duplicate ) vn ( stack items)]pdoc
    nlp  (<) (0) pfx   [(copy the ) vnth ( stack item)]pdoc

    nl  (C-)pc (j)k    [(Duplicate ) vy]ss
    nlp  (=) (0) pfx   (duplicate entire stack)pdoc
                       % [{lx x=} FC (or ) FKC(LFD)]ss
    nlp  (>) (0) pfx   [(duplicate ) vn ( stack items)]pdoc
    nlp  (<) (0) pfx   [(copy the ) vnth ( stack item)]pdoc

    nl       (DEL)k    [(Delete (pop) ) vx]ss
    nlp  (=) (0) pfx   (clear entire stack)pdoc
    nlp  (>) (0) pfx   [(delete ) vn ( stack items)]pdoc
    nlp  (<) (0) pfx   [(delete ) vnth ( stack item)]pdoc

    nl       (TAB)k    [(Swap ) vx ( & ) vy]ss
    nlp  (=) (0) pfx   (reverse entire stack)pdoc
    nlp  (>) (0) pfx   [(move ) vx ( to position ) vn (, rotate items downward)]pdoc
    nlp  (<) (0) pfx   [(rotate entire stack downward ) vn ( times)]pdoc

    nl (M-)pc (TAB)k   [(Same as ) [FK(TAB)] (, but rotates upward)]ss
    small-vs

    nl         (d [)k  [(Move stack pointer up)   {(down)s-width x+} {[(¯ «) {/tx1 CX store} (freezes» part of the stack)]com}]ss
    nl         (d ])k  [(Move stack pointer down)                    {[{tx1 x=} (as a place to hold values)]com}]ss
    small-vs

    nl (M-3)pk (m g)k  [(Current stack size)]ss
    nl         (~)k    [(Pop top-of-stack, and use it as preÎx for the next command)]ss
    nl         (K)k    (Perform next operation, but keep arguments on stack)ss
    nl (M-)pc  (RET)k  (Push arguments to last operation back onto stack)ss
    sect-vs
} def

/meta-ops
{
    (Meta operations) head

    nl        (U)k    (Undo)ss
    nl        (D)k    (Redo)ss
    nl (M-)pc (RET)k  (Recall last operation's arguments)ss
    nl        (`)k    ((backtick))com [( Edit top of stack. ) [FK(C-c C-c)] ( to return)]ss
    nl        (w)k    (Display recent error messages)ss
    nl (C-)pc (g)k    (Abort command in progress)ss
    nl (C-x * 0)buf-cmd ((zero))com [( Reset calculator to initial state)]ss
    sect-vs
} def

/display-modes
{
    (Display Modes) head

    nl         (I)k    [(Note: ) [FK(I)] ( preÎx before any display mode affects only the top-of-stack,)]com
    nlct               [(and only temporarily. Handy for base conversions, and prior to ) [FK(C-k)] ( copying.)]com
    nl         (P)k    (Precision)ss
    nl         (m r)k  (Radians)ss
    nl         (m d)k  (Degrees )ss ((default))com

    nl         (d 2)k  [(Display in ) {/tx1 CX store} (binary)]ss
    nl         (d 8)k  [{tx1 x=} (octal)]ss
    nl         (d 0)k  [{tx1 x=} (decimal)]ss
    nl         (d 6)k  [{tx1 x=} (hexadecimal)]ss
    nl         (d r)k  [(\(with preÎx\))]com [{tx1 x=} (arbitrary radix from 2¬36)]ss

    small-vs
    nl         (d f)k  (Fixed-point display)ss
    nl         (d n)k  [(Floating-point ) {((normal))com} ( display)]ss
    nl         (d s)k  [(ScientiÎc notation)]ss
    nl         (d e)k  (Engineering notation)ss
    small-vs
    nl         (d l)k  [(Line numbers on/off ) {((useful before copy/kill))com}]ss
    nl         (d o)k  (Fraction display. Enter one or two characters)ss
    nlct               [FT (One char \(e.g. )  [FK(:)]  (\) for improper fraction display: ) [FK(51:8)]]com
    nlct               [FT (Two chars \(e.g. ) [FK(+/)] (\) for mixed-fraction display: )    [FK(6+3/8)]]com
    small-vs
    nl         (m a)k  (Toggle algebraic/normal data entry mode)ss
    nl         (d B)k  («Big» display mode, for viewing algebraic formulas)ss
    nl         (d N)k  (Normal display mode)ss
    sect-vs
} def

/killing-etc
{
    (Killing, Copying, Yanking) head

    nl (C-)pc  (k)k     (Kill stack item at cursor)ss
    nl (M-)pc  (k)k     (Copy stack item at cursor to kill ring)ss
    nl (C-)pc  (w)k     (Kill stack item between mark & point)ss
    nl (M-)pc  (w)k     (Copy stack item between mark & point)ss
    nlp (>) (0) pfx     [(copy/kill ) vn ( lines starting at the current stack position)]pdoc
    nlp (<) (0) pfx     [(copy/kill ) vn ( lines above the current stack position)]pdoc
    nl (C-)pc  (y)k     (Yank from kill ring)ss
    nl         (y)k     (Copies top of stack into most-recently-used buffer)ss
    small-vs

    nlc (Note: the following commands are to be used in Emacs buffers other than the Calc buffer.)com
    nl (C-x * g)buf-cmd (Parse region in current buffer, into a vector of values)ss
    nlp (=) (0) pfx     [(grabs current line)]pdoc
    nlp (>) (0) pfx     [(grabs from point to ) vn ( lines forward)]pdoc
    nl (C-x * r)buf-cmd (Parse region in current buffer as a rectangle (matrix) of values)ss
    nlp pfx-any         (matrix will have only 1 column)pdoc
    nl (C-x * :)buf-cmd (Grab a rectangle of numbers in columns, sum them)ss
    nl (C-x * _)buf-cmd (Grab a rectangle of numbers in rows, sum them)ss
    small-vs
    nl (C-x * y)buf-cmd [(Copies top of stack HERE ) {((in some other buffer))com}]ss
    sect-vs
} def

/rounding
{
    (Rounding) head

    nl         (R)k    (Round to nearest integer)ss
    nl  (I)pk  (R)k    [(Truncate to integer (round towards zero) ) {((also truncates dates))com}]ss
    ejr? {
    nl  (z)pk (r)k     [(Round to ) [FV(preÎx)] ( decimal places ) {[(\(negative preÎx means round to left of decimal\))]com}]ss
    }{
    nl [(´)FT(round\($,)vn(\))]ss     [{xt x=} (Round to ) [FV(pfx)] ( decimal places ) {((negative n means round to left of decimal))com}]ss
    } ifelse
    nl        (F)k     [(Floor; truncate toward )  [FM(­æ)] ( ) {((also truncates dates))com}]ss
    nl  (I)pk (F)k     [(Ceiling; truncate toward ) [FM(+æ)]]ss
    nl  (1)pk (%)k     [(Fractional part of ) vx]ss
    sect-vs
} def

/general-math
{
    (General arithmetic) head

    nl         (&)k    [(Inverse: 1/) FV(x)]ss
    nl         (\\)k   (Integer division)ss
    nl         (:)k    (Fraction division)ss
    nl         (%)k    (Modulo)ss
    nl         (A)k    [(|)vx {ts}(| ¯ absolute value, or complex magnitude)]ss
    nl         (f s)k  (Sign operator, returns ­1, 0, or 1)ss
    nl         (f n)k  [(Minimum of )vx( and )vy]ss
    nl         (f x)k  [(Maximum of )vx( and )vy]ss
    nl         (f [)k  [(Decrement )vx]ss
    nl         (f ])k  [(Increment )vy]ss
    small-vs
    nl         (=)k    [(Evaluate ) {((formula, variable, etc.))com}]ss
    nlct               [[FT(some predeÎned variables: )] (e, pi, i, phi, gamma, inf, nan)]com
    sect-vs
} def

/algebraic-ops
{
    (Algebraic operations) head

    nl         (Q)k    (Square root)ss
    nl (I)pk   (Q)k    [vx(²)]ss
    nl         (L)k    [(Natural logarithm: ln\()vx(\))]ss
    nl         (E)k    [(e) FVS(x)]ss
    nl (I)pk   (L)k    [(Also e) FVS(x)]ss
    nl (H)pk   (L)k    [(Common logarithm ) {((base 10))com}]ss
    nl (I H)pk (L)k    [(10)FVS(x)]ss
    nl         (B)k    [(log)[FVs(x)] (\()vy(\)) ]ss
    nl         (^)k    [(General exponent: y)FVS(x)]ss
    nl (I)pk   (^)k    [(General root: ) {vy vx radical}]ss
    nl         (f h)k  [(Hypotenuse operation: ) {[vx(² + )vy(²)] root}]ss
    sect-vs
} def

/trigonometry
{
    (Trigonometry) head

    nlc [(    Note: ) [FK(I)] ( preÎx for inverse; ) [FK(H)] ( preÎx for hyperbolic)]com
    nl         (S)k    (Sine)ss
    nl         (C)k    (Cosine)ss
    nl         (T)k    (Tangent)ss
  % nl         (f T)k  [(Two-argument arctangent: \() [FV(y/x)] (\))]ss
    nl         (f T)k  [(Two-argument arctangent: \() {vy vx a-over-b} (\))]ss
    nl         (P)k    [(Push ) [FG(p)] ( onto the stack)]ss
    sect-vs
} def

/complex-numbers
{
    (Complex numbers) head

    nl         (J)k    (Conjugate)ss
    nl         (A)k    (Magnitude (absolute value))ss
    nl         (G)k    (Argument (angle))ss
    nl         (f r)k  (Real portion)ss
    nl         (f i)k  (Imaginary portion)ss
    nl         (d c)k  [(Display as \() [FV(real)] (,) [FV(imag)] (\)  ) {((default))com}]ss
    nl         (d i)k  [(Display as )   [FV(real)] (+) [FV(imag)] ( i)]ss
    nl         (c p)k  [(Convert rectangular ) [FM([) {-2 x+} (])] ( polar)]ss
    nl         (m p)k  (Toggle between polar and rect display preference)ss
    sect-vs
} def

/percentages
{
    (Percentages) head

    % arbitrarily line up arrows, might look nicer that way:
    1 dict begin
    /conv-str (Convert a decimal to a percent: 0.085 ) def 
    nl   (M-)pc (%)k    [(Convert )vx( to percentage:) {xt x= conv-str s-width x+ (8.5 )s-rshow}  [FM(])] ( 8.5%)]ss
    nl          (c %)k  [conv-str [FM(])] ( 8.5%)]ss
    end
    nl  (M-)pc  (% *)k  [(Compute ) vx {ts} (% of ) vy]ss
    nl (/ &)pk  (c %)k  [(Compute what percent ) vx ( is of ) vy]ss
    nl          (b %)k  [(Compute percent change from ) vy ( to ) vx]ss
    sect-vs
} def

/combinatorics
{
    (Combinatorics) head

    nl         (k g)k    (GCD of two integers or fractions)ss
    nl         (k l)k    (LCM of two integers or fractions)ss
    nl         (k E)k    [(Extended GCD: returns vector )[FK([)] [FV(g, a, b)] [FK(])] (, where ) [FV(g)] ( is the GCD, and ) [FV(g)][FM( = )][FV(ax)][FM( + )][FV(by)](.)]ss
    nl         (!)k      (Factorial function)ss
    nl         (k g)k    (Euler gamma function)ss
    nl         (k d)k    (Double factorial)ss
    small-vs
    nl         (k c)k    [(Combinations: \() vy ( choose ) vx (\))]ss
    nl  (H)pk  (k c)k    [(Permutations: \() vy ( permute ) vx (\))]ss
    nl         (k f)k    [(Compute prime factors of ) vx]ss
    nl         (k p)k    [(Test whether )vx( is prime)]ss
    nl         (k n)k    [(Compute next prime larger than )vx]ss
    nl  (I)pk  (k n)k    [(Compute next prime smaller than )vx]ss
    nl         (k t)k    [(Euler´s totient function ) [FG(ø)] (\()vn(\))]ss
    sect-vs
} def

/random-numbers
{
    (Random Numbers) head

    nl    (k r)k     [(Random number in the interval ) [FK([)] (0 , ) vx [FK(\))]]ss
    nlct             [(Result will be integer or Êoat, depending on x's type)]com
    nlp   pfx-any    (Use argument instead of top-of-stack)pdoc
    nl    (k a)k     (Random-again: make another with the same parameters)ss
    small-vs

    nl    (k h)k     [(ShufÊe: Pick )vx( elements from )vy(, without duplicates)]ss
    nlct             [vy ( may be a vector )[FT((set))] (, interval, or error form)]com
    nlct             [(If )vy( is an integer or Êoat, values are drawn from the interval ) [FK([)] (0 , ) vy [FK(\))]]com
    nlp  (>) ( 0)pfx [(Draw )vn( elements from )vx( ) {[(\(instead of )vy(\))]com}] pdoc
    nlp  (=) (­1)pfx [(ShufÊe elements of vector )]pdoc
    sect-vs
}def

/conversions
{
    (Conversions) head

    nl   (c f)k  [(Convert to Êoating-point)]ss
    nl   (c F)k  (Convert to fraction approximation)ss
    nl   (c d)k  (Convert to degrees (from radians))ss
    nl   (c r)k  (Convert to radians (from degrees))ss
    nl   (c h)k  (convert angle to HMS form)ss
    sect-vs
}def

/binary
{
    (Binary) head

    nl   (b c)k      («Clip» to current word size)ss
    nlp  (>) (0)pfx  (word size (default: 32))pdoc
    nl   (b w)k      (Set word size, in bits)ss
    nl   (b a)k      (Bitwise AND)ss
    nl   (b o)k      (Bitwise OR)ss
    nl   (b x)k      (Bitwise XOR)ss
    nl   (b n)k      (Bitwise NOT)ss
    nl   (b u)k      (Unpack binary number into a vector of bit position indices)ss
    nl   (b p)k      (Pack such a vector into a binary number)ss
    small-vs
    nlc  (There are also a ton of shift & rotate operations not listed here)com
    sect-vs
}def

/logical
{
    (Logical operations) head
    nlc (Note: 0 represents «false»; 1 (or any nonzero value) represents «true»)com

    nl    (a =)k    [(Does )vy( equal )vx(?)]ss
    nl    (a #)k    [(Is )vy( not equal to )vx(?)]ss
    nl    (a <)k    [(Is )vy( less than )vx(?)]ss
    nl    (a [)k    [(Is )vy( less than or equal to )vx(?)]ss
    nl    (a >)k    [(Is )vy( greater than )vx(?)]ss
    nl    (a ])k    [(Is )vy( greater than or equal to )vx(?)]ss
    nl    (a {)k    [(Is )vy( in the interval or set )vx(?)]ss
    small-vs

    nl    (a &)k    [(AND: )vx( and )vy( both true?)]ss
    nl    (a |)k    [(OR: Either )vx( or )vy( true?)]ss
    nl    (a !)k    [(NOT: Invert truth of )vx]ss
    nl    (a :)k    [(Decision: If )vz( is true, then )vy(; else )vx]ss
    small-vs

    nl    
    sect-vs
}def

/date-time
{
    (Date-Time operations) head

    nl        (t N)k    (Push current date/time onto stack)ss
    nl        (t N F)k  (Current date only)ss
    nl        (x time)k (Current time only)ss
    nl        (t U)k    (Convert date to/from Unix epoch seconds)ss
    nl        (t D)k    (Convert date to/from julian number)ss
    nl        (t C)k    (Convert time between time zones)ss
    nl   (I)pk  (R)k    [(Truncate date ) {((remove time portion))com}]ss
    ejr?
    {
        small-vs
        nl       (z s)k    (Convert time to/from seconds since midnight )ss ( (also converts date to HMS form))com
        nl (H)pk (z s)k    (Convert seconds without making the result a modulo form)ss
        nl (I)pk (z s)k    (Convert HMS form or seconds since midnight to a fraction)ss
    } if
    small-vs
    nl        (t P)k    (Extract date/time components:)ss
    nlp  (=) (1,2,3) pfx-r  (year, month, or day)pdoc
    nlp  (=) (4,5,6) pfx-r  (hour, minute, or second)pdoc
    nlp  (=)     (7) pfx-r  [(weekday: 0=Sunday ) [FM /arrowright] ( 6=Saturday)]pdoc
    nlp  (=)     (8) pfx-r  (day of year)pdoc
    nlp  (=)     (9) pfx-r  (time, as HMS form)pdoc

    nl        (v P)k    (Pack stack elements into a date or time:)ss
    nlp  (=)    (­3) pfx-r  [(Make a time (HMS) from top three stack elements \() [FV(hour ) [FK(z)] (, minute )[FK(y)] (, second )[FK(x)] (\))]]pdoc
    nlp  (=)   (­14) pfx-r  [(Make a date (YMD) from top three stack elements \() [FV(year ) [FK(z)] (, month ) [FK(y)] (, day )   [FK(x)] (\))]]pdoc
    nlp  (=)   (­15) pfx-r  [(Make a date/time from top six stack elements)]pdoc
    small-vs

    nl          (t M)k  [(Change day-of-month.  With no preÎx arg, becomes Îrst day of month)]ss
    nlp  (=) (0)pfx     (last day of month)pdoc
    nlp  (>) (0)pfx     [(change day to ) FV(n)]pdoc

    nl          (t Y)k  [(Change day-of-year.  With no preÎx arg, becomes Îrst day of year)]ss
    nlp  (=) (0)pfx     (last day of year)pdoc
    nlp  (<) (0)pfx     [/fi(rst day of ) vnth ( month)]pdoc
    nlp  (>) (0)pfx     [(change day-of-year to ) FV(n)]pdoc

    nl          (t W)k  [(Change day-of-week  With no preÎx arg, becomes Sunday on or before ) vx]ss
    nlp  (>) (0)pfx     [(speciÎed day-of-week on or before ) FV(x)]pdoc

    small-vs
    nl          (t I)k  [(Increment month \(add 1 month to ) vx (\))]ss
    nlp  pfx-any        [(add ) vn ( months to date)]pdoc
    
    nl          (f [)k  [(Decrement date by 1 day, or date/time by 1 second)]ss
    nl          (f ])k  [(Increment date by 1 day, or date/time by 1 second)]ss
    small-vs
    nl          (t +)k  (Add business days)ss
    nl          (t -)k  (Subtract business days)ss
    nl          (s H)k  (Edit business holidays)ss

    sect-vs
} def

/units
{
    (Units) head
    nlc (Note: enter units expressions in algebraic mode)com

    nl    (u c)k    (Convert units)ss
    nl    (u s)k    (Simplify units-expression)ss
    nl    (u t)k    [(Convert temperature units ) FV(degF ) [FM([) {-2 x+} (])] ( degC)]ss
    nl    (u r)k    (Strip units from expression at top of stack)ss
    nl    (u v)k    (Display units table)ss
    nl    (u g)k    [(Explain a speciÎed unit's description)]ss
    nl    (u e)k    (Explain (in words) the units on the top of the stack)ss
    nl    (u d)k    (Create a new unit from the expression on top of stack)ss
    nl    (u p)k    [(Store user-deÎned units permanently ) {((in calc.el))com}]ss
    small-vs

    /tx1 lx store
    /tx2 lx 30 add store
    /tx3 tx2 [FT (composite)] s-width add store
    nlc  tx1 x=  [FT (Common units)]com
    nlc  tx2 x=  [FT (length)]com      tx3 x=  (m, in, ft, yd, mi, lyr, nmi, point)com
    nlc  tx2 x=  [FT (volume)]com      tx3 x=  (l, gal, qt, pt, cup, ozfl)com
    nlc  tx2 x=  [FT (time)]com        tx3 x=  (s, min, hr, day, wk, yr, Hz)com
    nlc  tx2 x=  [FT (mass)]com        tx3 x=  (g, lb, oz, ton, t)com
    nlc  tx2 x=  [FT (speed)]com       tx3 x=  (kph, mph, knot, c)com
    nlc  tx2 x=  [FT (temp)]com        tx3 x=  (degF, degC, degK, dF, dC, dK)com
    nlc  tx2 x=  [FT (composite)]com   tx3 x=  (mfi, vol, hms)com
    nlc  tx2 x=  [FT (electrical)]com  tx3 x= [(J, W, A, V, ohm, ) [FM(O)]]com
    nlc  tx2 x=  [FT (misc)]com        tx3 x=  (ga, N, dyn, bar, atm, psi, mol)com

    sect-vs
} def

/storing-recalling
{
    (Storing/recalling) head

    nl        (s s)k   [(Store )vx ( ) {((prompts for variable name))com}]ss
    nl        (s t)k   [(Store )vx ( and pop it from stack)]ss
    nl        (s x)k   (Exchange variable with top-of-stack)ss
    nl        (s u)k   [(UndeÎne a variable)]ss
    nl        (s e)k   (Edit a variable)ss
    small-vs
    nl        (s +)k   [(Pop )vx ( and add:) {50 x+ /tx1 CX store} FV (var ) [FM([)] ( var ) [FM(+)] ( x)]ss
    nl        (s *)k   [(Pop )vx ( and multiply:) {tx1 x=} FV (var ) [FM([)] ( var ) [FM(*)] ( x)]ss
    nl        (s -)k   [(Pop )vx ( and subtract:) {tx1 x=} FV (var ) [FM([)] ( var ) [FM(­)] ( x)]ss
    nl (I)pk  (s -)k   [(Pop )vx ( and subtract:) {tx1 x=} FV (var ) [FM([)] ( x )   [FM(­)] ( var)]ss
    nl        (s /)k   [(Pop )vx ( and divide:)   {tx1 x=} FV (var ) [FM([)] ( var ) [FM(/)] ( x)]ss
    nl (I)pk  (s /)k   [(Pop )vx ( and divide:)   {tx1 x=} FV (var ) [FM([)] ( x )   [FM(/)] ( var)]ss

    small-vs
    nl        (s n)k   (Negate the value of a variable)ss
    nl        (s &)k   (Invert the value of a variable)ss
    nl        (s [)k   (Decrement the value of a variable)ss
    nl        (s ])k   (Increment the value of a variable)ss
    
    sect-vs
} def

/stack-trail
{
    (Stack Trail) head

    nl        (t d)k  (Toggle trail display)ss
    nlp  (=) (0) pfx  (turn trail display off)pdoc
    nlp  (=) (1) pfx  (turn it on)pdoc
    nl        (t i)k  (Go into the trail window)ss
    nl        (t o)k  (Go out of the trail window)ss
    nl        (t [)k  [(Move to the Îrst trail entry)]ss
    nl        (t ])k  (Move to the last trail entry)ss
    nl        (t p)k  (Move to the previous trail entry)ss
    nl        (t n)k  (Move to the next trail entry)ss
    nl        (t b)k  (Move back one screen)ss
    nl        (t f)k  (Move forward one screen)ss
    nl        (t h)k  (Move trail pointer HERE (to the cursor point))ss
    small-vs
    nl        (t y)k  (Yank current trail entry to stack)ss
    nl        (t k)k  (Kill the current trail line)ss
    small-vs
    nl        (t m)k  [(Mark; enter a string to be used as a label ) {((e.g. for searching))com}]ss
    nl        (t s)k  (Search forward in trail)ss
    nl        (t r)k  (Search backward in trail)ss
    sect-vs
}def

/programming
{
    (Programming) head

    nlc (Note: the letter Z in this section is uppercase, except where noted.)com
    nl  (C-)pc  (x \()k  (Start recording keyboard macro)ss
    nl  (C-)pc  (x \))k  (Stop recording)ss
    nl          (X)k     [(Execute macro \(or use ) [FK(C-x e)] (\))]ss
    small-vs
    nl          (Z D)k   [(DeÎne: bind an existing calc command to a ) [FK(z)] (-key)]ss
    nl [(z ) FV(key)]k   [[{((lowercase z))com}] ( Invoke ) [FK(z)] (-key binding)]ss
    nl          (z ?)k   [[{((lowercase z))com}] ( List bound ) [FK(z)] (-keys ) {((while prompting to invoke one))com}]ss
    nl          (Z F)k   (Store formula (algebraic expression) at top of stack)ss
    nl          (Z G)k   (Retrieve stored formula)ss
    nl          (Z K)k   [(Bind a keyboard macro to a ) [FK(z)] (-key)]ss
    nl          (Z E)k   [(Edit keyboard macro, or formula, bound to a ) [FK(z)] (-key. ) [FK(C-c C-c)] ( to end)]ss
    nl          (Z U)k   [(Forget a ) [FK(z)] (-key binding)]ss
    nl          (Z P)k   [(Make a ) [FK(z)] (-key binding permanent ) {[(\(via config Île calc.el\))]com}]ss
    sect-vs
} def

/flow-control
{
    (Flow control in keyboard macros) head
    nlc [(Note: ) [FK(Z[)] (, ) [FK(Z:)] (, and ) [FK(Z|)] ( expect (and consume) a boolean value from the stack.)]com

    nl [{xt x=}  FV (bool ) [FK(Z[)] ( ¨ ) [FK(Z])] ]ss 
    nl [{xt x=}  FV (bool ) [FK(Z[)] ( ¨ ) [FK(Z:)] ( ¨ ) [FK(Z])] ]ss 
    nl [{xt x=}  FV (bool ) [FK(Z[)] ( ¨ ) [FK(Z:)] ( bool ) [FK(Z|)] ( ¨ ) [FK(Z:)] ( bool ) [FK(Z|)] ( ¨ ) [FK(Z:)] ( ¨ ) [FK(Z])] ]ss
    small-vs

    nl          (Z [)k   [(IF ¯ pops )vx (, then if:)]ss
    nlp (=) (0)pfx-x     [(skip to ) [FK(Z:)] ( or ) [FK(Z])]]pdoc
    nlp /notequal (0)pfx-x     [(keep executing until ) [FK(Z:)] ( or ) [FK(Z])]]pdoc
    nl          (Z :)k   (ELSE)ss
    % nl [FK(Z: ) [FV(bool)] ( Z|)]ss  [FT {xt x=} (ELSE IF)]ss
    nl (Z :)pk  (Z |)k   [(ELSE IF¯ pops )vx(, then if )vx [FM( Ø )] (0, keeps executing here, else skips to next ) [FK(Z:)] ( or )[FK(Z])]]ss
    nl          (Z ])k   (END IF)ss
    small-vs

    nl          (Z <)k   [(Counted loop.  Pops )vx (, then loops for )vx ( times \()vx ( > 0\))]ss
    nl          (Z >)k   (End counted loop)ss
    % nl [FV(bool)]pk (Z |)k   [(Conditional break; pops )vx (, then if )vx [FM( Ø )] (0, breaks out of ) [FK(Z<) [FV( ¨ )] (Z>)] ( loop)]ss
    nl          (Z |)k   [(Conditional break; pops )vx (, then if )vx [FM( Ø )] (0, breaks out of ) [FK(Z<) [FV( ¨ )] (Z>)] ( loop)]ss
    small-vs

    nl          (Z \()k  [(For loop: )vy ( is initial value, )vx ( is Înal value. ) {(Loop counter is pushed onto stack each iteration.)com}]ss
    nl [FV(step)]pk (Z \))k  [(End for-loop. )vx ( is the step value, and is required.)]ss
    small-vs

    nl [FV(prompt)]pk  (Z #)k   [(Pause execution, prompt user to enter an algebraic expression. )vx ( is user prompt ) {((string))com}]ss
    nl          (Z /)k   [(Break out of the innermost loop construct.)]ss
    
    sect-vs
}def


/vector-building
{
    (Vectors (building)) head

    nl         (v x)k    [(Build vector of integers from 1 to ) FV(preÎx)]ss
    nl (C-u)pk (v x)k    [(Build vector of ) vz ( elements, starting at ) vy ( and incrementing ) vx ( each time)]ss
    nl         (v b)k    [(Build vector of ) [FV(preÎx)] ( copies of ) vx]ss
    nl         (v i)k    [(Build an identity matrix of order ) [FV(preÎx)]]ss
    nl         (v d)k    [(Create a diagonal square matrix \(of order ) [FV(preÎx)] (\) from ) vx]ss
    small-vs

    nl         (|)k      (Append (concatenate) two scalar or vector values)ss
    nl (I)pk   (|)k      [(Prepend values \(in reverse order as ) [FK(|)] (\))]ss

    sect-vs
} def

/vector-extraction
{
    (Vectors (extracting)) head

    nl         (v h)k    [(Return head ) {[(\(Îrst element\))]com} ( of vector)]ss
    nl (I)pk   (v h)k    (Return vector with head removed)ss
    nl (I H)pk (v h)k    (Return last element of vector)ss
    nl (H)pk   (v h)k    (Return vector with last element removed)ss
    small-vs

    nl         (v r)k    [(Extract ) vnth ( row/element of matrix/vector )]ss ((n is 1-based!))com
    nlp (<) (0)pfx [(Return matrix/vector with ) vnth ( element removed)]pdoc
    nlp (=) (0)pfx [(Extract diagonal values ) {((of a matrix))com}]pdoc
    nl (C-u)pk (v r)k    [(Use ) vx ( as preÎx. May be an integer, vector, or interval.)]ss
    nl         (v c)k    [(Like ) [FK(v r)] (, but acts column-wise instead of row-wise)]ss

    sect-vs
} def

/vector-ops
{
    (Vector operations) head

    nl         (v l)k    (Length of vector)ss
    nl  (H)pk  (v l)k    (Dimensions of vector, matrix, etc)ss
    nl         (v t)k    (Transpose matrix)ss
    nl         (v v)k    (Reverse vector)ss
    nl         (v a)k    [(Rearrange matrix to have ) [FV(preÎx)] ( columns)]ss
    small-vs

    nl         (V S)k    (Sort vector elements)ss
    nl  (I)pk  (V S)k    (Sort, descending order)ss
    nl         (V G)k    (Grade: produce sorting-index vector)ss
    nl  (I)pk  (V G)k    (Grade, descending order)ss
    nl         (v f)k    [(Find ) {((1-based))com} ( index of value )vx ( in vector )vy]ss
    nl         (V H)k    [(Histogram; ) [FV(preÎx)] ( is number of bins)]ss
    small-vs

    nl         (V C)k    (Cross-product of two 1x3 vectors)ss
    nl         (*)k      (Dot-product of two vectors, or matrix multiplication)ss
    nl         (V T)k    [(Matrix trace ) {((diagonal elements))com}]ss
    small-vs
    nl         (&)k      (Matrix inverse)ss
    nl         (V D)k    (Determinant of (square) matrix)ss
    nl         (V J)k    (Complex conjugate transposition of matrix)ss
    nl         (A)k      (Matrix norm (Frobenius norm))ss

    sect-vs
} def

/linear-algebra
{
    (Linear algebra) head

    nl         (&)k      (Matrix inverse)ss
    nl         (V D)k    (Determinant of (square) matrix)ss
    nl         (A)k      (Matrix norm (Frobenius norm))ss
    nl         (v n)k    [(InÎnity-norm of vector, or row-norm of matrix)]ss
    nl         (V N)k    (One-norm of vector, or column-norm of matrix)ss
    nl         (V L)k    (LU-decomposition of matrix)ss
    nl         (V K)k    (Kronecker product of two matrices)ss
    sect-vs
}def

/vectors-as-sets
{
    (Vectors as sets) head

    nl         (V #)k    (Count number of integers in a set)ss
    nl         (V +)k    (Remove dups )ss   ((usually unnecessary; implicit in other set operations))com
    nl         (V V)k    (Set union)ss
    nl         (V ^)k    (Set intersection)ss
    nl         (V -)k    (Set difference)ss
    nl         (V X)k    (XOR two sets)ss
    nl         (V ~)k    (Complement set )ss ((wrt real numbers))com
    nl         (V F)k    (Convert set to integers)ss
    nl         (V E)k    (Enumerate set; expand intervals )ss ((integer sets only))com
    nl         (V :)k    (Convert set into an interval form that spans it)ss

    nl         (a {)k    [(Boolean: Is )vy( in the set )vx(? )]ss [(\(also works if )vx( is an interval\))]com
    sect-vs
} def

/vector-packing
{
    (Vector packing/unpacking) head
    1 dict begin
    /xpvr xpvR def   % adjust spacing on right-justified numbers

    nl         (V p)k   [(Pack vector from stack elements)]ss
    nl         (V u)k   [(Unpack vector into stack elements)]ss
    nlp (>)   (0)pfx-r  [(Pack ) vn ( stack elements into a vector of length ) vn]pdoc
    nlp (=)  (­1)pfx-r  [(Rectangular complex number: ) {/tx1 CX store} vy ( + ) vx [FK(i)]]pdoc
    nlp (=)  (­2)pfx-r  [(Polar complex number:) {tx1 x=} [FV(r = y)] (, ) [FG(t)] ( = ) vx]pdoc
    nlp (=)  (­3)pfx-r  [(HMS time form:)        {tx1 x=} vz ( hours, ) vy ( minutes, ) vx ( seconds)]pdoc
    nlp (=)  (­4)pfx-r  [(Error form: )          {tx1 x=} vy ( ) [FM /plusminus] ( ) vx]pdoc
    nlp (=)  (­5)pfx-r  [(Modulo form:)          {tx1 x=} vy ( mod ) vx]pdoc
    nlp (=)  (­6)pfx-r  [(Interval form:)        {tx1 x=} [FK([) ] vy ( .. ) vx [FK(]) ] ]pdoc
    nlp (=)  (­7)pfx-r  [(Interval form:)        {tx1 x=} [FK([) ] vy ( .. ) vx [FK(\))] ]pdoc
    nlp (=)  (­8)pfx-r  [(Interval form:)        {tx1 x=} [FK(\()] vy ( .. ) vx [FK(]) ] ]pdoc
    nlp (=)  (­9)pfx-r  [(Interval form:)        {tx1 x=} [FK(\()] vy ( .. ) vx [FK(\))] ]pdoc
    nlp (=) (­10)pfx-r  [(Fraction:)             {tx1 x=} {vy vx a-over-b}] pdoc
    nlp (=) (­11)pfx-r  [(Floating-point exponential:) {tx1 x=} vy FM( * 10)FVS(x) ]pdoc
    nlp (=) (­12)pfx-r  (same as ­11, but mantissa is Êoating-point)com
    nlp (=) (­13)pfx-r  [(Real number converted to/from date form)]pdoc
    nlp (=) (­14)pfx-r  [(Date form:)            {tx1 x=} vz ( years ) vy ( month ) vx ( day)]pdoc
    nlp (=) (­15)pfx-r  [(Six values to date/time: year, month, day, hour, minute, second)]pdoc

    end
    sect-vs
} def

/mapping
{
    (Vector mapping/reduction) head

    nl         (V M)k    (Map a function across one or more vectors )ss ((one for each function argument))com
    nl         (V M :)k  (Map by columns )ss ((of a matrix))com
    nl         (V M _)k  (Map by rows )ss ((of a matrix))com
    small-vs

    nl         (V R)k    (Reduce a vector, by applying a binary function repeatedly)ss
    nl  (I)pk  (V R)k    (Reduce, applying function from right-to-left)ss
    nl         (V R :)k  (Reduce by columns )ss ((of a matrix))com
    nl         (V R _)k  (Reduce by rows )ss ((of a matrix))com
    nl         (V U)k    (Reduce, accumulating intermediate values)ss
    nl  (I)pk  (V U)k    (Reduce, right-to-left, accumulating values)ss
    small-vs

    nl         (V O)k    (Generalized outer product )ss [(\(two vectors, one function )  [FM(»)] ( matrix\))]com
    nl         (V I)k    (Generalized inner product )ss [(\(two vectors, two functions ) [FM(»)] ( vector\))]com
    small-vs

    nl         (V A)k    [(Apply a function to a vector¯use the vector elements as function arguments)]ss
    sect-vs
} def

/symbolic-algebra
{
    (Algebraic (symbolic) manipulation) head
    nlc[(Notes: Enter algebraic expressions with ) [FK(')] ( (apostrophe).)]com
    nlc[(Edit algebraic expressions with ) [FK(`)] ( (backtick).)]com
    nlc(Enter systems of related equations as vectors of equations.)com
    
    nl         (a S)k  (Solve equation/inequality/system for speciÎed variable)ss
    nl  (H)pk  (a S)k  (Solve, reporting general family of solutions)ss
    nlct               [[FV(s1)] (, ) [FV(s2)] (, etc. represent signs)]com
    nlct               [[FV(n1)] (, ) [FV(n2)] (, etc. represent integers)]com
    small-vs
    nl         (a l)k  [(Evaluate expression, Îrst setting a variable temporarily)]ss
    nl         (a c)k  [(Collect terms involving a speciÎed variable)]ss
    nl         (a x)k  (Expand expression )ss ((by applying distributive law))com
    nl         (a n)k  (Arrange formula into quotient of polynomials)ss
    nl         (a a)k  (Expand rational polynomial by partial fractions)ss
    small-vs
    nl         (a R)k  [(Find root of equation in )vy (; ) vx( is initial guess)]ss
    nl         [{xt x=} (Returns ) FV ([root, error])]ss
    small-vs
    nl         (a N)k  [(Find local minimum of equation in )vy (; ) vx( is initial guess)]ss
    nl         (a X)k  [(Find local maximum of equation in )vy (; ) vx( is initial guess)]ss
    nl         [{xt x=} (Returns ) FV ([root, min/max value])]ss
    small-vs

    sect-vs
} def

/summations
{
    (Summations) head

    nl         (a +)k  [(Sum formula \(in ) vx (\), prompting for index bounds)]ss
    nl         (a ­)k  (Same, but alternating sum)ss
    nl         (a *)k  [(Product formula in ) vx]ss
    nl         (a T)k  (Evaluate formula over range of inputs, returning vector of results)ss

    sect-vs
} def

/calculus
{
    (Calculus) head

    nl         (a d)k  (Compute derivative of expression)ss
    nl  (H)pk  (a d)k  (Ditto; does not assume other variables are constant)ss
    nl         (a i)k  (IndeÎnite integral)ss
    nl (C-u)pk (a i)k  (DeÎnite integral; prompts for bounds)ss
    nl         (a I)k  (Numeric integration)ss

    sect-vs
} def

%%%-------------------------------------------------------------------------------------
% Page definitions

/font-test-page
{
    lx ty M
    font-test-section
    showpage
} def

/front-cover
{
    /page-label () def
    cx cy moveto
    FF setfont
    doc-title s-cshow

    % 306 396 moveto
    % /Times-Roman 24 selectfont
    % (HEY PRINT THIS!) show

    FPN setfont
    rx by moveto
    [{/tx1 CX store}   (Last updated: ) doc-date] s-rshow
    tx1 x=  fsN y+  [(Version: ) doc-version] s-show

    % % Registration marks for final booklet cutting:
    % 1 dict begin
    % /d 11 def
    % newpath

    % lx by M
    % 0 d neg RM
    % d neg 0 RL
    % stroke

    % lx ty M
    % 0 d RM
    % d neg 0 RL
    % stroke

    % rx ty M
    % 0 d RM
    % d 0 RL
    % 0 d neg RL
    % stroke

    % rx by M
    % 0 d neg RM
    % d 0 RL
    % 0 d RL
    % stroke
    % end

    showpage

}def

/page1
{
    /page-label (1) def
    lx ty M
    data-entry
    stack-ops
    meta-ops
    showpage
} def

/page2
{
    /page-label (2) def
    lx ty moveto
    display-modes
    killing-etc
    rounding
    showpage
} def

/page3
{
    /page-label (3) def
    lx ty moveto
    general-math
    algebraic-ops
    trigonometry
    complex-numbers
    showpage
} def

/page4
{
    /page-label (4) def
    lx ty moveto
    percentages
    combinatorics
    random-numbers
    conversions
    binary
    showpage
} def

/page5
{
    /page-label (5) def
    lx ty moveto
    date-time
    units
    showpage
} def

/page6
{
    /page-label (6) def
    lx ty moveto
    storing-recalling
    stack-trail
    showpage
} def

/page7
{
    /page-label (7) def
    lx ty moveto

    vector-building
    vector-extraction
    vectors-as-sets
    vector-packing
    showpage
} def

/page8
{
    /page-label (8) def
    lx ty moveto

    vector-ops
    mapping
    ejr? not {linear-algebra} if
    showpage
} def

/page9
{
    /page-label (9) def
    lx ty moveto

    symbolic-algebra
    summations
    calculus
    showpage
} def

/page10
{
    /page-label (10) def
    lx ty moveto

    programming
    logical
    flow-control
    showpage
} def

/blank-page
{
    /page-label () def
    showpage
}def

% Display one index entry at vertical position <y>
%--->    [(label)  (pgnum)]   <one-ix>   --
/one-ix
{
    fsH y-       % drop down

    % draw dots
    tx1 x=
    {
        CX tx2 ge {exit} if
        (. ) show
    } loop

    aload pop    % (section name)   (page num)
    tx3 x= s-rshow   % show page num

    % show section name
    lx x=
    dup s-bounds gsave 1 setgray rect fill grestore
    s-show
}def

/index-page
{
    /page-label () def
    lx ty moveto
    % Display a heading, but don't add it to the index
    1 dict begin    (Index) head    end

    % Find longest, shortest strings
    FT setfont
    /tx1 999 store
    /tx2   0 store
    index-entries
    {
        0 get s-width
        dup tx1 lt {/tx1 1 index store} if
        dup tx2 gt {/tx2 1 index store} if
        pop
    } forall

    % convert to x-positions
    % tx1 = left side of section name
    % tx2 = end of dots
    % tx3 = right side of page number
    /tx1 tx1 lx add store
    /tx2 tx2 lx add 60 add store
    /tx3 tx2 (99) stringwidth pop add store

    % Sort the list
    /index-entries  index-entries {index-cmp} bubble-sort  store

    4 dict begin
    /cnt  index-entries length def
    /c1   cnt 1 add 2 idiv def
    /c2   cnt c1 sub def
    /ty1  CY def
    % Display the first half in one column
    index-entries  0 c1 getinterval
    {one-ix} forall
    % Display the second half in a second column
    gsave
    ty1 y=
    cx 0 translate
    index-entries  c1 c2 getinterval
    {one-ix} forall
    grestore

    % % Registration marks for final booklet cutting:
    % 1 dict begin
    % /d 11 def
    % newpath

    % lx by M
    % 0 d neg RM
    % d neg 0 RL
    % 0 d RL
    % stroke

    % lx ty M
    % d neg 0 RM
    % 0 d RL
    % d 0 RL
    % stroke

    % rx ty M
    % 0 d RM
    % d 0 RL
    % stroke

    % rx by M
    % 0 d neg RM
    % d 0 RL
    % stroke
    % end
    
    showpage
} def
/index-cmp
{
    1 index 0 get
    1 index 0 get
    2 copy lt
    {
        4 {pop} repeat
        true
    }
    {
        eq
        {
            1 get exch 1 get exch
            lt
        }
        {pop pop false}
        ifelse
    }
    ifelse
} def


%%%-------------------------------------------------------------------------------------
% Output

/eopp-backside?  false def

/end-of-physical-page
{
    Nup 4 eq
    {
        eopp-backside?
        {
            <<
                /xdiv   PPW 2 div
                /ydiv   PPH 6 div
            >> begin
            0 setlinewidth
    
            % % Test of clipping region (??)
            % 0.9 setgray
            % newpath
            % -600 -800 moveto
            % 1200 -800 lineto
            % 1200 1600 lineto
            % -600 1600 lineto
            % closepath fill
    
            % Staple marks
            newpath
            xdiv  ydiv        M  0  -36  RL
            xdiv  ydiv 2 mul  M  0   36  RL
            xdiv  ydiv 4 mul  M  0  -36  RL
            xdiv  ydiv 5 mul  M  0   36  RL
            stroke
    
            % Additional vertical registration marks
            xdiv  0    M    0   20  RL
            xdiv  PPH  M    0  -20  RL
            stroke
    
            % Horizontal "cut here" line
            PPW  PPH 2 div dup 0 exch M L stroke
            end
        } if
    } if

    /eopp-backside? eopp-backside? not def
} def

% booklet style!
Nup
[

    1
    {
        pop
        front-cover
        page1
        page2
        page3
        page4
        page5
        page6
        page7
        page8
        page9
        page10
        index-page
    }

    2
    {
        pop
        page5 page6
        page7 page4

        page3 page8
        page9 page2

        page1 page10
        index-page front-cover
    }
    4
    {
        pop
        page3 page8
        page5 page6
        page9 page2
        page7 page4

        page1 page10
        blank-page blank-page
        index-page front-cover
        blank-page blank-page
    }
]cond
