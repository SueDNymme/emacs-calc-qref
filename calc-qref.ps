%!PS

% Eric's GNU Emacs Calc quick reference booklet.
%
% This is intended to be printed as a quarter-page booklet, stapled,
% trimmed, and kept near the computer for quick reference.

%%% ---------------------------------------------------------------------------------
%%% Document configuration

/doc-version  (1.02.00)     def
/doc-date     (2015 MAY 18) def

(qref-config.ps) run

% Defaults:
/def-if-not-def{1 index where{pop pop pop}{def}ifelse}def

/Nup           4     def-if-not-def     % Number of pages per physical sheet: 1, 2, or 4
/ejr?          false def-if-not-def     % Prints stuff specific to my configuration
/color         false def-if-not-def     % This does nothing yet
/large-print?  true  def-if-not-def     % Makes fonts slightly larger
/doc-title     [(Eric's) (Gnu Emacs Calc) (Quick Reference Guide)] def-if-not-def

% Page margins (scaled, for the small virtual pages)
/lm  54  def-if-not-def    % ¾"
/rm  54  def-if-not-def    % ¾"
/tm  54  def-if-not-def    % ¾"
/bm  54  def-if-not-def    % ¾"

% Adjust document version if "large-type edition"
large-print? {/doc-version [doc-version (-LP)] def} if

% For the Creative Commons icon EPS:
/AI3_noCropMarks true def

%%% ---------------------------------------------------------------------------------
%%% Library functions

% (../postscript-utils/error.ps) run
/bd {bind def}bind def
/LD {load def}bd
/--lines{{dup 2 le{pop exit}if --lines-pop2 L}loop}bd
/--lines-pop2{dup -2 add exch -2 roll}bd
/BCA{3 -1 roll}bd
/C  /currentpoint LD
/CAB{3 1 roll}bd
/CL /closepath LD
/CX{C pop}bd
/CY{C exch pop}bd
/EncodeFont{findfont dup maxlength dict copy dup /FID undef begin ISOLatin1Encoding 1 index type/arraytype eq{[exch aload pop] exch{1 index exch aload pop 1 index type /stringtype eq{exch 0 get exch}if put}forall}if /Encoding exch def dup /FontName exch def currentdict end definefont pop}bd
/Hline{{C newpath M initmatrix initclip 0 setlinewidth -100 C exch pop M 1000 0 RL S}gprotect}bd
/L  /lineto LD
/M  /moveto LD
/RL /rlineto LD
/RM /rmoveto LD
/S  /stroke LD
/all-true{true exch{2 index exch exec not{not exit}if}forall exch pop}bd
/any-true{false exch{2 index exch exec{not exit}if}forall exch pop}bd
/bubble-sort{1 index length 1 sub -1 1{2 index exch 2 copy get 3 copy 0 1 3 index 1 sub{3 index 1 index get 2 index 1 index 10 index exec{4 2 roll}if pop pop}for 4 -1 roll exch 4 1 roll put put}for pop}bd
/cond{true exch{exch{false}{exch dup type /booleantype eq{{exec exit}{pop true}ifelse}{2 index exch dup xcheck{exec}{eq}ifelse{exec exit}{pop true}ifelse}ifelse}ifelse}forall}bd
/gprotect{gsave exec grestore}bd
/in{72 mul}bd
/radical{C 2 dict begin/om matrix currentmatrix def translate currentfont/FontMatrix get 3 get currentfont/FDepVector known{currentfont/FDepVector get 0 get/FontMatrix get 3 get mul}if dup scale/m matrix currentmatrix def gsave 400 400 M om setmatrix 0.66667 dup scale s-rshow grestore gsave newpath 90 80 M 73.1 116.3 L 236.2 192.3 L 410.7 -181.7 L 712.8 865.8 L 807.1 865.8 L 807.1 800.8 L 747.1 800.8 L 426.2 -297.0 L 374.4 -297.0 L 171.6 118.0 L closepath fill grestore 807.1 0 M om setmatrix s-show m setmatrix C pop 80 add newpath dup dup 800.8 M 865.8 L 807.1 865.8 L 807.1 800.8 L closepath fill 0 M om setmatrix}bd
/rect{4 2 roll M rectto}bd
/rectto{C newpath M exch 2 copy C exch 2 copy 8 3 roll L L L L CL}bd
/root{C 2 dict begin/om matrix currentmatrix def translate currentfont/FontMatrix get 3 get currentfont/FDepVector known{currentfont/FDepVector get 0 get/FontMatrix get 3 get mul}if dup scale/m matrix currentmatrix def gsave newpath 90 80 M 73.1 116.3 L 236.2 192.3 L 410.7 -181.7 L 712.8 865.8 L 807.1 865.8 L 807.1 800.8 L 747.1 800.8 L 426.2 -297.0 L 374.4 -297.0 L 171.6 118.0 L closepath fill grestore 807.1 0 M om setmatrix s-show m setmatrix C pop 80 add newpath dup dup 800.8 M 865.8 L 807.1 865.8 L 807.1 800.8 L closepath fill 0 M om setmatrix}bd
/s /show LD
/s-bounds{1 dict begin/old-mode s-show-dict/mode get def s-show-dict/mode false put gsave C nulldevice newpath M s-show flattenpath pathbbox grestore s-show-dict/mode old-mode put end}bd
/s-cshow{dup s-width -2 div 0 RM s-show}bd
/s-rshow{dup s-width neg 0 RM s-show}bd
/s-show{1 dict begin[{type/stringtype eq}{s-show-dict/mode get{s}{true charpath}ifelse}{type/nametype eq}{s-show-dict/mode get{glyphshow}{C BCA glyphshow C 4 2 roll M 2 copy L S M}ifelse}{xcheck}{[exch s-show-dict/Uexec get exec]dup length 0 eq{pop}{s-show}ifelse}{/is-f-obj? where{pop is-f-obj?}{pop false}ifelse}{/previous-font dup dup where{exch get null eq}{pop false}ifelse{f-current store}{pop}ifelse f-usefont}{s-show-dict/is-font? get exec}{/previous-font dup dup where{exch get null eq}{pop false}ifelse{currentfont store}{pop}ifelse setfont}{type/arraytype eq}{[{0 get/matrix eq}{/previous-matrix dup dup where{exch get null eq}{pop false}ifelse{matrix currentmatrix store}{pop}ifelse 1 get concat}true{/previous-font null def/previous-matrix null def{s-show}forall/previous-font load[null{pop}{/is-f-obj? where{pop is-f-obj?}{pop false}ifelse}{f-usefont}{s-show-dict/is-font? get exec}{setfont}true{dup errordict/typecheck get exec}]cond/previous-matrix load[null{pop}{type/arraytype eq}{setmatrix}true{dup errordict/typecheck get exec}]cond}]cond}true{dup errordict/typecheck get exec}]cond end}bd
/s-show-dict<</mode true/Udict<<>>/Uexec{s-show-dict/Udict get begin exec end}bind /is-font?{[{type/dicttype eq}{/FontType known}{/Encoding known}{[{[{/FontType get 0 eq} {/FMapType known}{/FDepVector known}]all-true}{[{/FontType get 1 eq}{/FontMatrix known} {/FontName known}]all-true}]any-true}]all-true}bind>>def
/s-width{gsave nulldevice 0 0 M s-show C pop grestore}bd
/x+{C CAB add exch M}bd
/x={C exch pop M}bd
/x=y-{C exch pop exch sub M}bd
/y+{C BCA add M}bd
/y-{C BCA sub M}bd
/y={C pop exch M}bd
/PaperSizes<</A4[595.28 841.89]/US-Letter[612 792]/US-Legal[612 1008]/Both[595.28 792]/Default/US-Letter>>readonly def
/*VP 10 dict def
*VP begin
/vn 0 def/nup 1 def/sf 1 def/orig null def *VP/SP 2 copy known{pop pop}{/showpage load put}ifelse/nupok<<1 true 2 true 4 true>>def
end
/showpage{/end-of-page dup where{exch get exec}{pop}ifelse *VP begin/vn vn 1 add def vn nup ge{/end-of-physical-page dup where{exch get GS setgstate currentdict exch end exec begin}{pop}ifelse SP/PPN PPN 1 add store/vn 0 def}if/pn pn 1 add store GS setgstate orient-subpage newpath 0 0 M pw 0 L pw ph L 0 ph L closepath clip end}def
/orient-subpage{*VP begin sf dup scale orig Landscape? get vn get aload pop translate rotate end}def
/1UP{*VP begin/vn 0 def/nup 1 def/sf 1 def/orig<<false[[0 0 0]]true[[90 PPW 0]]>>def end}def
/2UP{*VP begin/vn 0 def/nup 2 def/sf PPH PPW 2 mul div def/orig<<false[[90 PPH 0][90 PPH PPW]]true[[0 0 PPW][0 0 0]]>>def end}def
/4UP{*VP begin/vn 0 def/nup 4 def/sf 0.5 def/orig<<false[[0 0 PPH][0 PPW PPH][0 0 0][0 PPW 0]]true[[90 PPW 0][90 PPW 2 mul 0][90 PPW PPH][90 PPW 2 mul PPH]]>>def end}def
/page-init{/Paper where{pop true}{false}ifelse/Duplex? where{pop true}{false}ifelse or/Paper PaperSizes/Default get def-if-not-def PaperSizes Paper 2 copy known not{pop dup/Default get/Paper 1 index store}if get aload pop/PPH exch def/PPW exch def/PPN 1 def/Duplex? false def-if-not-def/Landscape? false def-if-not-def/Nup 1 def-if-not-def/lm 0 def-if-not-def/rm 0 def-if-not-def/tm 0 def-if-not-def/bm 0 def-if-not-def *VP/nupok get Nup known not{/Nup 1 def}if{<</PageSize[PPW PPH]/Duplex Duplex?>>setpagedevice}if *VP/GS 2 copy known{pop pop}{gstate currentgstate put}ifelse *VP/OM 2 copy known{pop pop}{matrix currentmatrix put}ifelse/ph{Landscape?{PPW}{PPH}ifelse}def/pw{Landscape?{PPH}{PPW}ifelse}def/pn 1 def/lx lm def/rx pw rm sub def/cx rx lx add 2 div def/by bm def/ty ph tm sub def/cy ty by add 2 div def Nup dup 1 eq{1UP}{dup 2 eq{2UP}{dup 4 eq{4UP}if}ifelse}ifelse pop orient-subpage}def

page-init

%%% ---------------------------------------------------------------------------------
%%% Font Setup

% FONT CONSIDERATIONS:
%
% The following categories of text are used by this document,
% and they have these font requirements:
%
% HEADING  (/FH)
%     Should be sans-serif (I think), and boldface.
%     No other particular requirements.
%
% KEYSTROKE (/FK, /FKC)
%     Should be monospace.
%     Zero should not be slashed or dotted; should be distinct from O.
%     Backtick and apostrophe should be distinct and symmetric.
%     Should also have straight-quote and straight-double-quote (' and ").
%     Capital/lower pairs (Zz, Ss, Xx) should be distinguishable.
%     The following characters are used, and should look good: [] () <> ^ % & | # _
%
% TEXT (/FT, /FPT)
%     Should be upright serif typeface (I think).
%     Must include the following: endash, emdash, quoteright, quoteleft, quotedblleft, quotedblright,
%                                 hyphen, ellipsis.
%     Should come in a boldface (/FB) and an italic (/FI) version.
%     Ligatures might be nice (fl, fi, Fl, Fi).
%     Would be nice if we could find one with left-arrow, right-arrow, both-arrow.
%
% VARIABLES (/FV, /FVC)
%     Should be an italic serif typeface.
%     Must include the following: endash, emdash, quotedblleft, quotedblright, hyphen, ellipsis,
%                                 multiply, divide.
%     Ligatures might be nice (fl, fi, Fl, Fi).
%
% PREFIX-ARGS (/FPA)
%     Should be oblique sans-serif.
%     Must include the following: minus, notequal
%
% PREFIX-ARG DESCRIPTIVE TEXT (/FPT)
%     Should be italic serif typeface.
%     Pretty much the same requirements as regular text.
%
% MATH SYMBOLS (/FM)
%     Must include the following: pi, sigma, theta, Omega, plusminus, notequal, infinity, minus
%
% COMMENTS (/FC)
%     Should be a smaller, italic version of TEXT (/FT).

% Load needed font files
(fonts/ucrb8a.pfa)  run    % Nimbus Mono L Bold
(fonts/uhvro8a.pfa) run    % Nimbus Sans L Regular Italic
(fonts/uhvr8v.pfa)  run    % Vn Nimbus Sans L
(fonts/utmr8a.pfa)  run    % Nimbus Roman No9 L Regular
(fonts/utmri8a.pfa) run    % Nimbus Roman No9 L Regular Italic

% Assign typefaces for different purposes.
/Typeface-for-Keystrokes     /NimbusMonL-Bold           def
/Typeface-for-Text           /NimbusRomNo9L-Regu        def
/Typeface-for-Text-Italic    /NimbusRomNo9L-ReguItal    def
/Typeface-for-Greek          /Symbol                    def
/Typeface-for-Prefix-Args    /NimbusSanL-ReguItal       def
/Typeface-for-Math           /Symbol                    def
/Typeface-for-Headings       /Helvetica-Bold            def
/Typeface-for-Page-Headings  /VnNimbusSansL             def
/Typeface-for-Front-Cover    /VnNimbusSansL             def

% ...and assign type sizes and other spacing
large-print?
{
    /fsT  13 def  % size for most text
    /fsC  11 def  % size for comments
    /fsP  12 def  % prefix-arg doco
    /fsH  15 def  % headings
    /fsN  13 def  % page numbers
    /fsF  24 def  % front cover title
    /body-small-vs   fsT 2 div def    % A small vertical spacing in between body text lines
    /begin-sect-vs   fsT 6 div def    % Vert space after heading, before body text
    /end-sect-vs     fsH def          % Vertical spacing at the end of a section
}
{
    /fsT  12 def  % size for most text
    /fsC   9 def  % size for comments
    /fsP  10 def  % prefix-arg doco
    /fsH  14 def  % headings
    /fsN  12 def  % page numbers
    /fsF  24 def  % front cover title
    /body-small-vs   fsT 2 div def    % A small vertical spacing in between body text lines
    /begin-sect-vs   fsT 6 div def    % Vert space after heading, before body text
    /end-sect-vs     fsH def          % Vertical spacing at the end of a section
} ifelse

% Define extra characters that we'll need encoded.
% This source file uses ISO-Latin1 encoding.
% The "&" sequences in the comments are RFC-1345 mnemonics.
/punc-chars  [[(´) /quoteright]    % &''
              [(`) /quoteleft]     % backtick
              [(«) /quotedblleft]  % &<<
              [(») /quotedblright] % &>>
              [(-) /hyphen]        % hyphen
              [(­) /minus]         % &--
              [(¬) /endash]        % &NO
              [(¯) /emdash]        % &'m
              [(Þ) /pi]            % &TH
              [(¨) /ellipsis]      % &':
              [(Ø) /notequal]      % &O/
              [(Î) /fi]            % &I>
              [(Ê) /fl]            % &E>
] def
/math-chars  [[(­) /minus]         % &--
              [(*) /multiply]
              [(/) /divide]
              [(Ø) /notequal]      % &O/
              [(«) /arrowdblleft]  % &<<
              [(») /arrowdblright] % &>>
              [(æ) /infinity]      % &ae
              [([) /arrowleft]
              [(]) /arrowright]
] def
/kbd-chars   [[(`)    /quoteleft]
              [(´)    /quoteright]    % &''
              [(')    /quotesingle]
] def
/greek-chars [[(p)    /pi]
              [(r)    /rho]
              [(ø)    /phi]      % &o/
              [(s)    /sigma]
              [(t)    /theta]
              [(O)    /Omega]
] def

% Load, encode, scale, and store fonts for the document

% Re-encode fonts as needed.
% Note that the *symbol* /Foo is different from the *variable* Foo.
% Here we make fonts, referred to by the symbolic /Foo, and one of the
% parameters is the typeface name, stored previously in the variable /Foo.
/Typeface-for-Keystrokes      kbd-chars    Typeface-for-Keystrokes     EncodeFont
/Typeface-for-Text            punc-chars   Typeface-for-Text           EncodeFont
/Typeface-for-Text-Italic     punc-chars   Typeface-for-Text-Italic    EncodeFont
/Typeface-for-Greek           greek-chars  Typeface-for-Greek          EncodeFont
/Typeface-for-Prefix-Args     punc-chars   Typeface-for-Prefix-Args    EncodeFont
/Typeface-for-Math            math-chars   Typeface-for-Math           EncodeFont
/Typeface-for-Headings        punc-chars   Typeface-for-Headings       EncodeFont
/Typeface-for-Page-Headings   punc-chars   Typeface-for-Page-Headings  EncodeFont
/Typeface-for-Front-Cover     punc-chars   Typeface-for-Front-Cover    EncodeFont
/Font-for-Keystrokes      /Typeface-for-Keystrokes     findfont def
/Font-for-Text            /Typeface-for-Text           findfont def
/Font-for-Text-Italic     /Typeface-for-Text-Italic    findfont def
/Font-for-Greek           /Typeface-for-Greek          findfont def
/Font-for-Prefix-Args     /Typeface-for-Prefix-Args    findfont def
/Font-for-Math            /Typeface-for-Math           findfont def
/Font-for-Headings        /Typeface-for-Headings       findfont def
/Font-for-Page-Headings   /Typeface-for-Page-Headings  findfont def
/Font-for-Front-Cover     /Typeface-for-Front-Cover    findfont def

% Certain parts of the quick-reference guide frequently switch between
% different typefaces, so we define composite (type 0) fonts for them.
% Each of these composite fonts is encoded so that its normal typeface
% is font-index 0, and the rest can be selected by the following
% sequence within strings:  ESC-CHAR CODE-CHAR
% Where ESC-CHAR is:
/ESC-CHAR  16#A7 def            % § "section"; RFC-1345 "SE".
% and CODE-CHAR is one of the following:
%      T   -  Text
%      K   -  Key sequences
%      V   -  Variables
%      M   -  Math notation
%      G   -  Greek letters
%      I   -  Italic text
%      B   -  Bold text         (not currently used)
%      E   -  Bold italic text  (not currently used)

/Composite-Font-Vector-Text  [
    Font-for-Text            %  0 T Text
    Font-for-Keystrokes      %  1 K Key sequences
    Font-for-Text-Italic     %  2 V Variables
    Font-for-Math            %  3 M Math notation
    Font-for-Greek           %  4 G Greek letters
    Font-for-Text-Italic     %  5 I Italic text
%   Font-for-Text-Bold       %  6 B Bold text
%   Font-for-Text-Emphatic   %  7 E Bold italic text
] def
/Composite-Font-Vector-Keys  [
    Font-for-Keystrokes      %  0 K Key sequences
    Font-for-Text            %  1 T Text
    Font-for-Text-Italic     %  2 V Variables
    Font-for-Math            %  3 M Math notation
    Font-for-Greek           %  4 G Greek letters
    Font-for-Text-Italic     %  5 I Italic text
%   Font-for-Text-Bold       %  6 B Bold text
%   Font-for-Text-Emphatic   %  7 E Bold italic text
] def
/Composite-Font-Vector-Notes [
    Font-for-Text-Italic     %  0 I Italic text
    Font-for-Text            %  1 T Text
    Font-for-Keystrokes      %  2 K Key sequences
    Font-for-Text-Italic     %  3 V Variables
    Font-for-Math            %  4 M Math notation
    Font-for-Greek           %  5 G Greek letters
%   Font-for-Text-Bold       %  6 B Bold text
%   Font-for-Text-Emphatic   %  7 E Bold italic text
] def

/Composite-Font-Encoding-Text  [
    48 {0} repeat    % control chars, punctuation
    10 {0} repeat    % 0..9
    7  {0} repeat    % more punctuation
%   A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    0 0 0 0 0 0 4 0 5 0 1 0 3 0 0 0 0 0 0 0 0 2 0 0 0 0 
] def
/Composite-Font-Encoding-Keys  [
    48 {0} repeat    % control chars, punctuation
    10 {0} repeat    % 0..9
    7  {0} repeat    % more punctuation
%   A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    0 0 0 0 0 0 4 0 5 0 0 0 3 0 0 0 0 0 0 1 0 2 0 0 0 0
] def
/Composite-Font-Encoding-Notes [
    48 {0} repeat    % control chars, punctuation
    10 {0} repeat    % 0..9
    7  {0} repeat    % more punctuation
%   A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
    0 0 0 0 0 0 5 0 0 0 2 0 4 0 0 0 0 0 0 1 0 3 0 0 0 0
] def

/FT dup
<<
    /FontType    0              % Composite font
    /FontMatrix  matrix         % Identity matrix
    /FMapType    3              % Escape mapping
    /EscChar     ESC-CHAR       % See above
    /Encoding    Composite-Font-Encoding-Text
    /FDepVector  Composite-Font-Vector-Text
>>
definefont fsT scalefont def
/FK dup
<<
    /FontType    0              % Composite font
    /FontMatrix  matrix         % Identity matrix
    /FMapType    3              % Escape mapping
    /EscChar     ESC-CHAR       % See above
    /Encoding    Composite-Font-Encoding-Keys
    /FDepVector  Composite-Font-Vector-Keys
>> definefont fsT scalefont def
/FC dup
<<
    /FontType    0              % Composite font
    /FontMatrix  matrix         % Identity matrix
    /FMapType    3              % Escape mapping
    /EscChar     ESC-CHAR       % See above
    /Encoding    Composite-Font-Encoding-Notes
    /FDepVector  Composite-Font-Vector-Notes
>> definefont fsC scalefont def

% Other text uses are much simpler, so we define simple Type 1 fonts for them:
/SF {findfont exch scalefont def}def
%/FK  fsT  /Typeface-for-Keystrokes     SF
%/FT  fsT  /Typeface-for-Text           SF
%/FI  fsT  /Typeface-for-Text-Italic    SF
/FV  fsT  /Typeface-for-Text-Italic    SF
%/FG  fsT  /Typeface-for-Greek          SF
%/FC  fsT  /Typeface-for-Text-Italic    SF
/FPA fsP  /Typeface-for-Prefix-Args    SF
/FPT fsP  /FT                          SF
/FM  fsT  /Typeface-for-Math           SF
/FH  fsH  /Typeface-for-Headings       SF
/FPN fsN  /Typeface-for-Page-Headings  SF
/FF  fsF  /Typeface-for-Front-Cover    SF

% Superscript/subscript fonts.
% FTS: Text superscript font. For numeric exponents.
% Use this only when numeric superscripts are not available in the base font,
% because these don't look as good. Most fonts have at least ² and ³.
/FTS   FT  [0.6 0 0 0.6   0  fsT 0.3 mul] makefont def
% FVS: Superscript font for (lowercase) variables, e.g. x and y.
/FVS   FV  [0.6 0 0 0.6   1  fsT 0.4 mul] makefont def
% FVs: Subscript font for (lowercase) variables, e.g. x and y.
/FVs   FV  [0.6 0 0 0.6   0  fsT -0.2 mul] makefont def

% Handy routines for setting the font in few characters
/f=t {FT  setfont}bd    % Set text font
/f=k {FK  setfont}bd    % Set keystroke font
/f=c {FC  setfont}bd    % Set comment/note font
/f=v {FV  setfont}bd    % Set prefix argument font
/f=a {FPA setfont}bd    % Set prefix argument font
/f=p {FPT setfont}bd    % Set prefix documentation font

% And for setting the font and showing a string
/s=t {f=t s-show}bd    % Set text font and show
/s=k {f=k s-show}bd    % Set keystroke font and show
/s=c {f=c s-show}bd    % Set comment/note font and show
/s=p {f=p s-show}bd    % Set prefix-doc font and show


%%% ---------------------------------------------------------------------------------
%%% Horizontal positions
FK setfont
/xp   lx (I H) s-width add def     % Start of letter prefix
/xk   xp ( ) s-width add def    % start of command keystroke
/xt   lx (C-x * G    ) s-width add def   % start of text
FPA setfont
/xpa  xt 27 add def                     % Prefix arg
% prefix operator position: centered on equals sign
/xpo  xpa (n )    stringwidth pop add (=) stringwidth pop 2 div add def
/xpv  xpa (n = )  stringwidth pop add def   % prefix value
/xpvr xpv (4,5,6) stringwidth pop add def   % prefix value (right-justified)
/xpvR xpv (­00)   stringwidth pop add def   % prefix value (alt right-justified)
/xpt  xpvr 9 add def                        % prefix text description

% Starting a new line (and similar)
/nl   {lx  fsT  x=y-} def
/nlh  {lx  fsH  x=y-  FH setfont} def   % header
/nlc  {lx  fsC  x=y-  FC setfont} def   % comment (left-margin)
/nlct {xt  fsC  x=y-  FC setfont} def   % comment (text column)
/nlp  {xpa fsP  x=y-  FPA setfont} def
/small-vs {body-small-vs y-} def
/sect-vs
{
    /deb-b CY store
    end-sect-vs y-
} def               % vertical space after a section


%%% ---------------------------------------------------------------------------------
%%% Routines

% Show a heading
/head
{
    % record index entry -- add to front of existing array
    /index-entries
    [
        [ 3 index  page-label ]
        index-entries aload pop
    ] def

    nlh show
    begin-sect-vs y-
} def

% Show a prefix key sequence on the current line.
/pk {FK setfont xp x= s-rshow} def

% Show a prefix chord on the current line
/pc {FK setfont xk x= s-rshow} def

% Show a command key sequence on the current line.
% Note: positions point, and sets font, for subsequent text documentation.
/k  {FK setfont xk x= s-show  xt x= FT setfont}def

% Show a data-entry expression, then position for text description
/data-ent
{
    FK setfont
    lx x=   s-show
    xt x=
    FT setfont
} def

% Describe numeric prefix options
/pfx
{
    FPA  setfont
    xpa  x= (n) show
    xpv  x=     s-show
    FM   setfont
    xpo  x=     s-cshow
    xpt  x=
    FPT  setfont
} def
/pfx-x
{
    FPA  setfont
    xpa  x= (x) show
    xpv  x=     s-show
    FM   setfont
    xpo  x=     s-cshow
    xpt  x=
    FPT  setfont
} def
/pfx-r
{
    FPA  setfont
    xpa  x= (n) show
    xpvr x=     s-rshow
    FM   setfont
    xpo  x=     s-cshow
    xpt  x=
    FPT  setfont
} def
/pfx-any
{
    FPA  setfont
    xpa  x= (any arg) show
    xpt  x=
    FPT  setfont
} def

% Calc command meant to be used from other buffers
/buf-cmd
{
    FK setfont
    lx x= s-show
    xt x=
    FT setfont
} def

% Page numbers and page headings
/end-of-page
{
    page-label () ne
    {
        FPN setfont
        rx ty  moveto   fsN y-
        [(Page ) page-label] s-rshow
    }if
} def

% Misc shortcut
/ss /s-show load def

% Show a fraction a/b
% assumes args are lowercase letters
/a-over-b
{
    0   fsT 5 div  rmoveto
    exch s-show

    0    fsT -5 div  rmoveto
    (/) show

    fsT  -8 div  fsT -5 div  rmoveto
    s-show
    0  fsT  5 div   rmoveto
} def

% Storage for temporary x-positions
/tx1 0 def
/tx2 0 def
/tx3 0 def
/tx4 0 def

% Index entries
/index-entries [] def

/copyright-notice
{
    gsave
    % Position icon's lower-left corner at the bottom-left of the page
    lx by translate
    -340 -278 translate

    % Call the EPS
    1 dict begin
    /showpage {} def
    (cc-by.eps) run
    end

    % Add the Creative Commons license text, plus a pointer to GitHub.
    470 324 M
    fsC y-
    (This work is licensed under the Creative Commons Attribution 4.0 International License.)s=c
    470 fsC x=y-
    (To view a copy of this license, visit http://creativecommons.org/licenses/by/4.0/.)s=c
    470 278 M
    (This document is stored on GitHub at https://github.com/SueDNymme/emacs-calc-qref)s=c
    grestore
} def


%%% -------------------------------------------------------------------------------------
%%% Section definitions

% The reference materials are stored in blocks; this makes it easier
% to rearrange (to make them fit on the pages, for example).

/data-entry
{
    (Data Entry) head

    % This section needs a bit more space in the left column
    2 dict begin
    % This one seems to be the longest data-entry expression:
    /complex-rect  (\(§V real §0,§V imag §K\)  )  def
    % Redefine text-x position for this section:
    FK setfont
    /xt  lx  complex-rect s-width add   def


    nl  (_§Vdigits)                   data-ent  [[FC((underscore))]  ( Negative sign in data entry)]ss
    nl  (§Vn§0 : §Vd)                 data-ent  (Fraction: §Vn§0 is numerator, §Vd§0 is denominator)ss
    nl  complex-rect                  data-ent  (Complex (rectangular form))ss
    nl  (\(§V r §0;§G t §0\))         data-ent  (Complex (polar form))ss
    nl  ([§V a §0,§V b §0,§V ¨ §0])   data-ent  (Vector. Nest vectors to make a matrix.)ss
    nl  ("§Vhello§0")                 data-ent  (String: vector of ASCII codes)ss
    nl  (´<§Vdate§0>)                 data-ent  (Date form \(rather Êexible\))ss
    nl  (§V16§Kh§V 40§Km§V 20§Ks)     data-ent  (HMS form (hour, minute, second))ss
    nl  (§V16§K@§V 40§K'§V 20§K")     data-ent  (HMS form (degree, minute, second))ss
    nl  (§V16§Ko§V 40§K'§V 20§K")     data-ent  (HMS form \(§Ko§0 represents «degree»\))ss
    nl  (§Vbase §0#§V number)         data-ent  (Use arbitrary radix. Example: §K16#09AB)ss
    nl  (§Vmean §0p§G s )             data-ent  (Error form: §Vmean §M±§V std dev)ss
    nl  (§Vnum §0M§V modulus)         data-ent  (Modulo form.)ss
    nl  ([§V num §0..§V num §0])      data-ent  (Closed interval)ss
    nl  ((§V num §0..§V num §0))      data-ent  (Open interval)ss
            [(  ) FC ((Mixed-intervals like §K\(..]§0 or §K[..\)§0 are also allowed))]ss
    nl  (´)                           data-ent  [[FC((apostrophe))] {/tx1 CX store} ( Enter expression in algebraic mode)]ss
    nl  (`)                           data-ent  [[FC((backtick))]   {tx1 x=}        ( Edit top of stack. §KC-c C-c§0 to return)]ss

    end
    sect-vs
} def

/stack-ops
{
    (Stack Operations) head

    nl      (RET)k     (Duplicate §Vx)ss
    nlp     (=) (0) pfx   (duplicate entire stack)s=p
    nlp     (>) (0) pfx   (duplicate §Vn§0 stack items)s=p
    nlp     (<) (0) pfx   (copy the §Vnth§0 stack item)s=p

    nl  (C-)pc (j)k    (Duplicate §Vy)ss
    nlp     (=) (0) pfx   (duplicate entire stack)s=p
                       % [{lx x=} FC (or ) FKC(LFD)]ss
    nlp     (>) (0) pfx   (duplicate §Vn§0 stack items)s=p
    nlp     (<) (0) pfx   (copy the §Vnth§0 stack item)s=p

    nl      (DEL)k     (Delete (pop) §Vx)ss
    nlp     (=) (0) pfx   (clear entire stack)s=p
    nlp     (>) (0) pfx   (delete §Vn§0 stack items)s=p
    nlp     (<) (0) pfx   (delete §Vnth§0 stack item)s=p

    nl       (TAB)k    (Swap §Vx§0 & §Vy)ss
    nlp     (=) (0) pfx   (reverse entire stack)s=p
    nlp     (>) (0) pfx   (move §Vx§0 to position §Vn§0, rotate items downward)s=p
    nlp     (<) (0) pfx   (rotate entire stack downward §Vn§0 times)s=p

    nl (M-)pc (TAB)k   (Same as §KTAB§0, but rotates upward)ss
    small-vs

    nl         (d [)k  [(Move stack pointer up)   {(down)s-width x+} {[(¯ «) {/tx1 CX store} (freezes» part of the stack)]s=c}]ss
    nl         (d ])k  [(Move stack pointer down)                    {[      {tx1 x=}        (as a place to hold values) ]s=c}]ss
    small-vs

    nl (M-3)pk (m g)k  (Current stack size)ss
    nl         (~)k    (Pop top-of-stack, and use it as preÎx for the next command)ss
    nl         (K)k    (Perform next operation, but keep arguments on stack)ss
    nl (M-)pc  (RET)k  (Push arguments to last operation back onto stack)ss
    sect-vs
} def

/meta-ops
{
    (Meta operations) head

    nl        (U)k      (Undo)ss
    nl        (D)k      (Redo)ss
    nl (M-)pc (RET)k    (Recall last operation's arguments)ss
    nl        (`)k      ((backtick))s=c ( Edit top of stack. §KC-c C-c§0 to return)ss
    nl        (w)k      (Display recent error messages)ss
    nl (C-)pc (g)k      (Abort command in progress)ss
    nl (C-x * 0)buf-cmd ((zero))s=c ( Reset calculator to initial state)ss
    sect-vs
} def

/display-modes
{
    (Display Modes) head

    nl         (I)k    (Note: §KI§0 preÎx before any display mode affects only the top-of-stack,)s=c
    nlct               (and only temporarily. Handy for base conversions, and prior to §KC-k§0 copying.)s=c
    nl         (P)k    (Precision)ss
    nl         (m r)k  (Radians)ss
    nl         (m d)k  (Degrees )ss ((default))s=c

    nl         (d 2)k  [(Display in ) {/tx1 CX store} (binary)]ss
    nl         (d 8)k                     tx1 x=      (octal)ss
    nl         (d 0)k                     tx1 x=      (decimal)ss
    nl         (d 6)k                     tx1 x=      (hexadecimal)ss
    nl         (d r)k  ((with preÎx))s=c  tx1 x=      (arbitrary radix from 2¬36)ss

    small-vs
    nl         (d f)k  (Fixed-point display)ss
    nl         (d n)k  [(Floating-point ) [FC((normal))] ( display)]ss
    nl         (d s)k  [(ScientiÎc notation)]ss
    nl         (d e)k  (Engineering notation)ss
    small-vs
    nl         (d l)k  (Line numbers on/off )ss ((useful before copy/kill))s=c
    nl         (d o)k  (Fraction display. Enter one or two characters)ss
    nlct               (§TOne char (e.g. §K:§T) for improper fraction display: §K51:8)s=c
    nlct               (§TTwo chars (e.g. §K+/§T) for mixed-fraction display: §K6+3/8)s=c
    small-vs
    nl         (m a)k  (Toggle algebraic/normal data entry mode)ss
    nl         (d B)k  («Big» display mode, for viewing algebraic formulas)ss
    nl         (d N)k  (Normal display mode)ss
    sect-vs
} def

/killing-etc
{
    (Killing, Copying, Yanking) head

    nl (C-)pc  (k)k     (Kill stack item at cursor)ss
    nl (M-)pc  (k)k     (Copy stack item at cursor to kill ring)ss
    nl (C-)pc  (w)k     (Kill stack item between mark & point)ss
    nl (M-)pc  (w)k     (Copy stack item between mark & point)ss
    nlp    (>) (0) pfx     (copy/kill §Vn§0 lines starting at the current stack position)s=p
    nlp    (<) (0) pfx     (copy/kill §Vn§0 lines above the current stack position)s=p
    nl (C-)pc  (y)k     (Yank from kill ring)ss
    nl         (y)k     (Copies top of stack into most-recently-used buffer)ss
    small-vs

    nlc (Note: the following commands are to be used in Emacs buffers other than the Calc buffer.)s=c
    nl (C-x * g)buf-cmd (Parse region in current buffer, into a vector of values)ss
    nlp    (=) (0) pfx     (grabs current line)s=p
    nlp    (>) (0) pfx     (grabs from point to §Vn§0 lines forward)s=p
    nl (C-x * r)buf-cmd (Parse region in current buffer as a rectangle (matrix) of values)ss
    nlp    pfx-any         (matrix will have only 1 column)s=p
    nl (C-x * :)buf-cmd (Grab a rectangle of numbers in columns, sum them)ss
    nl (C-x * _)buf-cmd (Grab a rectangle of numbers in rows, sum them)ss
    small-vs
    nl (C-x * y)buf-cmd (Copies top of stack HERE )ss ((in some other buffer))s=c
    sect-vs
} def

/rounding
{
    (Rounding) head

    nl         (R)k    (Round to nearest integer)ss
    nl  (I)pk  (R)k    (Truncate to integer (round towards zero) )ss      ((also truncates dates))s=c

    ejr? {
    nl  (z)pk (r)k     (Round to §VpreÎx§0 decimal places )ss             ((negative preÎx means round to left of decimal))s=c
    }{
    nl (´§Tround($,§Vn§0))ss   xt x= (Round to §Vpfx§0 decimal places )ss ((negative n means round to left of decimal))s=c
    } ifelse

    nl        (F)k     (Floor; truncate toward §M­æ§0 )ss                 ((also truncates dates))s=c
    nl  (I)pk (F)k     (Ceiling; truncate toward §M+æ)ss
    nl  (1)pk (%)k     (Fractional part of §Vx)ss
    sect-vs
} def

/general-math
{
    (General arithmetic) head

    nl         (&)k    (Inverse: 1/§Vx  )ss ((Also inverts matrices.))s=c
    nl         (\\)k   (Integer division)ss
    nl         (:)k    (Fraction division)ss
    nl         (%)k    (Modulo)ss
    nl         (A)k    (| §Vx §0| ¯ absolute value, or complex magnitude)ss
    nl         (n)k    (Negate §Vx)ss
    nl         (f s)k  (Sign operator, returns ­1, 0, or 1)ss
    nl         (f n)k  (Minimum of §Vx§0 and §Vy)ss
    nl         (f x)k  (Maximum of §Vx§0 and §Vy)ss
    nl         (f [)k  (Decrement §Vx)ss
    nl         (f ])k  (Increment §Vx)ss
    small-vs
    nl         (=)k    (Evaluate )ss ((formula, variable, etc.))s=c
    nlct               (§Tsome predeÎned variables: §0e, pi, i, phi, gamma, inf, nan)s=c
    sect-vs
} def

/algebraic-ops
{
    (Algebraic operations) head

    nl         (Q)k    (Square root)ss
    nl (I)pk   (Q)k    (§Vx§0²)ss
    nl         (L)k    (Natural logarithm: ln(§Vx§0))ss
    nl         (E)k    [(e) FVS(x)]ss
    nl (I)pk   (L)k    [(Also e) FVS(x)]ss
    nl (H)pk   (L)k    (Common logarithm )ss ((base 10))s=c
    nl (I H)pk (L)k    [(10)FVS(x)]ss
    nl         (B)k    [(log)[FVs(x)] (\(§Vy§0\)) ]ss
    nl         (^)k    [(General exponent: y)FVS(x)]ss
    nl (I)pk   (^)k    (General root: )ss   f=v (y) (x) radical
    nl         (f h)k  [(Hypotenuse operation: ) {(§Vx§0² + §Vy§0²) root}]ss
    sect-vs
} def

/trigonometry
{
    (Trigonometry) head

    nlc (    Note: §KI§0 preÎx for inverse; §KH§0 preÎx for hyperbolic)s=c
    nl         (S)k    (Sine)ss
    nl         (C)k    (Cosine)ss
    nl         (T)k    (Tangent)ss
    nl         (f T)k  [(Two-argument arctangent: \() FV {(y) (x) a-over-b} (\))]ss
    nl         (P)k    (Push §Gp§0 onto the stack)ss
    sect-vs
} def

/complex-numbers
{
    (Complex numbers) head

    nl         (J)k    (Conjugate)ss
    nl         (A)k    (Magnitude (absolute value))ss
    nl         (G)k    (Argument (angle))ss
    nl         (f r)k  (Real portion)ss
    nl         (f i)k  (Imaginary portion)ss
    nl         (d c)k  (Display as (§Vreal§0,§Vimag§0)  )ss ((default))s=c
    nl         (d i)k  (Display as §Vreal§0+§Vimag§0 i)ss
    nl         (c p)k  [(Convert rectangular ) [(§M[) {-2 x+} (§M])] ( polar)]ss
    nl         (m p)k  (Toggle between polar and rect display preference)ss
    sect-vs
} def

/percentages
{
    (Percentages) head

    % arbitrarily line up arrows, might look nicer that way:
    1 dict begin
    /conv-str (Convert a decimal to a percent: 0.085 ) def 
    nl   (M-)pc (%)k    [(Convert §Vx§0 to percentage:) {xt x= conv-str s-width x+ (8.5 )s-rshow}  (§M]§0 8.5%)]ss
    nl          (c %)k  [conv-str (§M]§0 8.5%)]ss
    end
    nl  (M-)pc  (% *)k  (Compute §Vx§0% of §Vy)ss
    nl (/ &)pk  (c %)k  (Compute what percent §Vx§0 is of §Vy)ss
    nl          (b %)k  (Compute percent change from §Vy§0 to §Vx)ss
    sect-vs
} def

/combinatorics
{
    (Combinatorics) head

    nl         (k g)k    (GCD of two integers or fractions)ss
    nl         (k l)k    (LCM of two integers or fractions)ss
    nl         (k E)k    (Extended GCD: returns vector §K[§Vg, a, b§K]§0, where §Vg§0 is the GCD, and §Vg§M = §Vax§M + §Vby§0.)ss
    nl         (!)k      (Factorial function)ss
    nl         (k e)k    (Euler gamma function)ss
    nl         (k d)k    (Double factorial)ss
    small-vs
    nl         (k c)k    (Combinations: (§Vy§0 choose §Vx§0))ss
    nl  (H)pk  (k c)k    (Permutations: (§Vy§0 permute §Vx§0))ss
    nl         (k f)k    (Compute prime factors of §Vx)ss
    nl         (k p)k    (Test whether §Vx§0 is prime)ss
    nl         (k n)k    (Compute next prime larger than §Vx)ss
    nl  (I)pk  (k n)k    (Compute next prime smaller than §Vx)ss
    nl         (k t)k    (Euler´s totient function §Gø§0(§Vn§0))ss
    sect-vs
} def

/random-numbers
{
    (Random Numbers) head

    nl    (k r)k     (Random number in the interval §K[§00, §Vx§K\))ss
    nlct             (Result will be integer or Êoat, depending on x's type)s=c
    nlp   pfx-any    (Use argument instead of top-of-stack)s=p
    nl    (k a)k     (Random-again: make another with the same parameters)ss
    small-vs

    nl    (k h)k     (ShufÊe: Pick §Vx§0 elements from §Vy§0, without duplicates)ss
    nlct             (§Vy§0 may be a vector §T(set)§0, interval, or error form)s=c
    nlct             (If §Vy§0 is an integer or Êoat, values are drawn from the interval §K[§00, §Vy§K\))s=c
    nlp  (>) ( 0)pfx (Draw §Vn§0 elements from §Vx§0 )s=p ((instead of §Vy§0))s=c
    nlp  (=) (­1)pfx (ShufÊe elements of vector )s=p
    sect-vs
}def

/conversions
{
    (Conversions) head

    nl   (c f)k  (Convert to Êoating-point)ss
    nl   (c F)k  (Convert to fraction approximation)ss
    nl   (c d)k  (Convert to degrees (from radians))ss
    nl   (c r)k  (Convert to radians (from degrees))ss
    nl   (c h)k  (Convert angle to HMS form)ss
    sect-vs
}def

/binary
{
    (Binary) head

    nl   (b c)k      («Clip» to current word size)ss
    nlp  (>) (0)pfx  (word size (default: 32))s=p
    nl   (b w)k      (Set word size, in bits)ss
    nl   (b a)k      (Bitwise AND)ss
    nl   (b o)k      (Bitwise OR)ss
    nl   (b x)k      (Bitwise XOR)ss
    nl   (b n)k      (Bitwise NOT)ss
    nl   (b u)k      (Unpack binary number into a vector of bit position indices)ss
    nl   (b p)k      (Pack such a vector into a binary number)ss
    small-vs
    nlc  (There are also a ton of shift & rotate operations not listed here; see manual 7.7 «Binary Number Functions»)s=c
    sect-vs
}def

/logical
{
    (Logical operations) head
    nlc (Note: 0 represents «false»; 1 (or any nonzero value) represents «true»)s=c

    nl    (a =)k    (Does §Vy§0 equal §Vx§0?)ss
    nl    (a #)k    (Is §Vy§0 not equal to §Vx§0?)ss
    nl    (a <)k    (Is §Vy§0 less than §Vx§0?)ss
    nl    (a [)k    (Is §Vy§0 less than or equal to §Vx§0?)ss
    nl    (a >)k    (Is §Vy§0 greater than §Vx§0?)ss
    nl    (a ])k    (Is §Vy§0 greater than or equal to §Vx§0?)ss
    nl    (a {)k    (Is §Vy§0 in the interval or set §Vx§0?)ss
    small-vs

    nl    (a &)k    (AND: §Vx§0 and §Vy§0 both true?)ss
    nl    (a |)k    (OR: Either §Vx§0 or §Vy§0 true?)ss
    nl    (a !)k    (NOT: Invert truth of §Vx)ss
    nl    (a :)k    (Decision: If §Vz§0 is true, then §Vy§0; else §Vx)ss
    small-vs

    nl    
    sect-vs
}def

/date-time
{
    (Date-Time operations) head
    nlc  (Note: Default time display is «§Thh§K@§T mm§K'§T ss§K"§T §Kmod§T 24§K@§T 0§K'§T 0§K"§0».)s=c
    nlc  (To remove the modulus, use §Kv u§0. To change the time/date display use §Kd h§0 or §Kd d§0.)s=c

    nl        (t N)k    (Push current date/time onto stack)ss
    nl        (t N F)k  (Current date only)ss
    nl        (x time)k (Current time only)ss
    nl        (t U)k    (Convert date to/from Unix epoch seconds)ss
    nl        (t D)k    (Convert date to/from julian number)ss
    nl        (t C)k    (Convert time between time zones)ss
    nl   (I)pk  (R)k    (Truncate date )ss ((remove time portion))s=c
    ejr?
    {
        small-vs
        nl       (z s)k    (Convert time to/from seconds since midnight )ss ( (also converts date to HMS form))s=c
        nl (H)pk (z s)k    (Convert seconds without making the result a modulo form)ss
        nl (I)pk (z s)k    (Convert HMS form or seconds since midnight to a fraction)ss
    } if
    small-vs
    nl        (t P)k    (Extract date/time components:)ss
    nlp  (=) (1,2,3) pfx-r  (year, month, or day)s=p
    nlp  (=) (4,5,6) pfx-r  (hour, minute, or second)s=p
    nlp  (=)     (7) pfx-r  (weekday: 0=Sunday §M]§0 6=Saturday)s=p
    nlp  (=)     (8) pfx-r  (day of year)s=p
    nlp  (=)     (9) pfx-r  (time, as HMS form)s=p

    nl        (v P)k    (Pack stack elements into a date or time:)ss
    nlp  (=)    (­3) pfx-r  (Make a time (HMS) from top 3 stack el'ts (§Vhr §Kz§V, min §Ky§V, sec §Kx§0))s=p
    nlp  (=)   (­14) pfx-r  (Make a date (YMD) from top 3 stack el'ts (§Vyr §Kz§V, mon §Ky§V, day §Kx§0))s=p
    nlp  (=)   (­15) pfx-r  (Make a date/time from top six stack elements)s=p
    small-vs

    nl          (t M)k  (Change day-of-month.  With no preÎx arg, becomes Îrst day of month)ss
    nlp  (=) (0)pfx     (last day of month)s=p
    nlp  (>) (0)pfx     (change day to §Vn)s=p

    nl          (t Y)k  (Change day-of-year.  With no preÎx arg, becomes Îrst day of year)ss
    nlp  (=) (0)pfx     (last day of year)s=p
    nlp  (<) (0)pfx     (Îrst day of §Vnth§0 month)s=p
    nlp  (>) (0)pfx     (change day-of-year to §Vn)s=p

    nl          (t W)k  (Change day-of-week  With no preÎx arg, becomes Sunday on or before §Vx)ss
    nlp  (>) (0)pfx     (speciÎed day-of-week on or before §Vx)s=p

    small-vs
    nl          (t I)k  (Increment month (add 1 month to §Vx§0))ss
    nlp  pfx-any        (add §Vn§0 months to date)s=p
    
    nl          (f [)k  (Decrement date by 1 day, or date/time by 1 second)ss
    nl          (f ])k  (Increment date by 1 day, or date/time by 1 second)ss
    small-vs
    nl          (t +)k  (Add business days)ss
    nl          (t -)k  (Subtract business days)ss
    nl          (s H)k  (Edit business holidays)ss

    sect-vs
} def

/units
{
    (Units) head
    nlc (Note: enter units expressions in algebraic mode)s=c

    nl    (u c)k    (Convert units)ss
    nl    (u s)k    (Simplify units-expression)ss
    nl    (u t)k    [(Convert temperature units §VdegF ) [(§M[) {-2 x+} (§M])] ( degC)]ss
    nl    (u r)k    (Strip units from expression at top of stack)ss
    nl    (u v)k    (Display units table)ss
    nl    (u g)k    (Explain a speciÎed unit's description)ss
    nl    (u e)k    (Explain (in words) the units on the top of the stack)ss
    nl    (u d)k    (Create a new unit from the expression on top of stack)ss
    nl    (u p)k    (Store user-deÎned units permanently )ss ((in calc.el))s=c
    small-vs

    /tx1 lx store
    /tx2 lx 30 add store
    /tx3 tx2 (§Tcomposite) s-width add store
    nlc  tx1 x=  (§TCommon units)s=c
    nlc  tx2 x=  (§Tlength)s=c      tx3 x=  (m, in, ft, yd, mi, lyr, nmi, point)s=c
    nlc  tx2 x=  (§Tvolume)s=c      tx3 x=  (l, gal, qt, pt, cup, ozfl)s=c
    nlc  tx2 x=  (§Ttime)s=c        tx3 x=  (s, min, hr, day, wk, yr, Hz)s=c
    nlc  tx2 x=  (§Tmass)s=c        tx3 x=  (g, lb, oz, ton, t)s=c
    nlc  tx2 x=  (§Tspeed)s=c       tx3 x=  (kph, mph, knot, c)s=c
    nlc  tx2 x=  (§Ttemp)s=c        tx3 x=  (degF, degC, degK, dF, dC, dK)s=c
    nlc  tx2 x=  (§Tcomposite)s=c   tx3 x=  (mfi, vol, hms)s=c
    nlc  tx2 x=  (§Telectrical)s=c  tx3 x=  (J, W, A, V, ohm, §MO)s=c
    nlc  tx2 x=  (§Tmisc)s=c        tx3 x=  (ga, N, dyn, bar, atm, psi, mol)s=c

    sect-vs
} def

/storing-recalling
{
    (Storing/recalling) head

    nl        (s s)k   (Store §Vx§0 )ss ((prompts for variable name))s=c
    nl        (s t)k   (Store §Vx§0 and pop it from stack)ss
    nl        (s x)k   (Exchange variable with top-of-stack)ss
    nl        (s u)k   (UndeÎne a variable)ss
    nl        (s e)k   (Edit a variable)ss
    small-vs
    nl        (s +)k   [(Pop §Vx§0 and add:) {50 x+ /tx1 CX store} (§Vvar §M[§V var §M+§V x)]ss
    nl        (s *)k   [(Pop §Vx§0 and multiply:) {tx1 x=}         (§Vvar §M[§V var §M*§V x)]ss
    nl        (s -)k   [(Pop §Vx§0 and subtract:) {tx1 x=}         (§Vvar §M[§V var §M­§V x)]ss
    nl (I)pk  (s -)k   [(Pop §Vx§0 and subtract:) {tx1 x=}         (§Vvar §M[§V x §M­§V var)]ss
    nl        (s /)k   [(Pop §Vx§0 and divide:)   {tx1 x=}         (§Vvar §M[§V var §M/§V x)]ss
    nl (I)pk  (s /)k   [(Pop §Vx§0 and divide:)   {tx1 x=}         (§Vvar §M[§V x §M/§V var)]ss

    small-vs
    nl        (s n)k   (Negate the value of a variable)ss
    nl        (s &)k   (Invert the value of a variable)ss
    nl        (s [)k   (Decrement the value of a variable)ss
    nl        (s ])k   (Increment the value of a variable)ss
    
    sect-vs
} def

/stack-trail
{
    (Stack Trail) head

    nl        (t d)k  (Toggle trail display)ss
    nlp     (=) (0) pfx  (turn trail display off)s=p
    nlp     (=) (1) pfx  (turn it on)s=p
    nl        (t i)k  (Go into the trail window)ss
    nl        (t o)k  (Go out of the trail window)ss
    nl        (t [)k  (Move to the Îrst trail entry)ss
    nl        (t ])k  (Move to the last trail entry)ss
    nl        (t p)k  (Move to the previous trail entry)ss
    nl        (t n)k  (Move to the next trail entry)ss
    nl        (t b)k  (Move back one screen)ss
    nl        (t f)k  (Move forward one screen)ss
    nl        (t h)k  (Move trail pointer HERE (to the cursor point))ss
    small-vs
    nl        (t y)k  (Yank current trail entry to stack)ss
    nl        (t k)k  (Kill the current trail line)ss
    small-vs
    nl        (t m)k  (Mark; enter a string to be used as a label )ss ((e.g. for searching))s=c
    nl        (t s)k  (Search forward in trail)ss
    nl        (t r)k  (Search backward in trail)ss
    sect-vs
}def

/programming
{
    (Programming) head

    nlc (Note: the letter Z in commands in this section is uppercase, except where noted.)s=c
    nl  (C-)pc  (x \()k  (Start recording keyboard macro)ss
    nl  (C-)pc  (x \))k  (Stop recording)ss
    nl          (X)k     (Execute macro (or use §KC-x e§0))ss
    small-vs
    nl          (Z D)k   (DeÎne: bind an existing calc command to a §Kz§0-key)ss
    nl [(z ) FV(key)]k   [[FC ((lowercase z))] ( Invoke §Kz§0-key binding)]ss
    nl          (z ?)k   [[FC ((lowercase z))] ( List bound §Kz§0-keys )]ss ((while prompting to invoke one))s=c
    nl          (Z F)k   (Store formula (algebraic expression) at top of stack)ss
    nl          (Z G)k   (Retrieve stored formula)ss
    nl          (Z K)k   (Bind a keyboard macro to a §Kz§0-key)ss
    nl          (Z E)k   (Edit keyboard macro, or formula, bound to a §Kz§0-key. §KC-c C-c§0 to end)ss
    nl          (Z U)k   (Forget a §Kz§0-key binding)ss
    nl          (Z P)k   (Make a §Kz§0-key binding permanent )ss (\(via conÎg Île calc.el\))s=c
    sect-vs
} def

/flow-control
{
    (Flow control in keyboard macros) head
    nlc (Note: §KZ[§0 and §KZ|§0 expect (and consume) a boolean value from the stack.)s=c

    nl xt x= (§Vbool §KZ[§V ¨ §KZ])ss
    nl xt x= (§Vbool §KZ[§V ¨ §KZ:§V ¨ §KZ])ss
    nl xt x= (§Vbool §KZ[§V ¨ §KZ:§V bool §KZ|§0 ¨ §KZ:§0 bool §KZ|§0 ¨ §KZ:§0 ¨ §KZ])ss
    small-vs

    nl          (Z [)k          (IF ¯ pops §Vx§0, then if:)ss
    nlp     (=) (0)pfx-x            (skip to §KZ:§0 or §KZ])s=p
    nlp     (Ø) (0)pfx-x            (keep executing until §KZ:§0 or §KZ])s=p
    nl          (Z :)k          (ELSE)ss
    nl (Z :)pk  (Z |)k          (ELSE IF¯ pops §Vx§0, then if §Vx§M Ø §00, keeps executing here, else skips to next §KZ:§0 or §KZ])ss
    nl          (Z ])k          (END IF)ss
    small-vs

    nl          (Z <)k          (Counted loop.  Pops §Vx§0, then loops for §Vx§0 times (§Vx§0 > 0))ss
    nl          (Z >)k          (End counted loop)ss
    nl          (Z |)k          (Conditional break; pops §Vx§0, then if §Vx§M Ø §00, breaks out of §KZ<§V ¨ §KZ>§0 loop)ss
    small-vs

    nl          (Z \()k         (For loop: §Vy§0 is initial value, §Vx§0 is Înal value. )ss (Counter pushed onto stack each iteration)s=c
    nl [FV(step)]pk (Z \))k     (End for-loop. §Vx§0 is the step value, and is required.)ss
    small-vs

    nl [FV(prompt)]pk  (Z #)k   (Pause prompt user to enter an algebraic expr §Vx§0 is user prompt )ss ((string))s=c
    nl          (Z /)k          (Break out of the innermost loop construct.)ss
    
    sect-vs
}def


/vector-building
{
    (Vectors (building)) head

    nl         (v x)k    (Build vector of integers from 1 to §VpreÎx)ss
    nl (C-u)pk (v x)k    (Build vector of §Vz§0 elements, starting at §Vy§0 and incrementing by §Vx§0 each time)ss
    nl         (v b)k    (Build vector of §VpreÎx§0 copies of §Vx)ss
    nl         (v i)k    (Build an identity matrix of order §VpreÎx)ss
    nl         (v d)k    (Create a diagonal square matrix (of order §VpreÎx§0) from §Vx)ss
    small-vs

    nl         (|)k      (Append (concatenate) two scalar or vector values)ss
    nl (I)pk   (|)k      (Prepend values (in reverse order as §K|§0))ss

    sect-vs
} def

/vector-extraction
{
    (Vectors (extracting)) head

    nl         (v h)k    [(Return head ) [FC(\(Îrst element\))] ( of vector)]ss
    nl (I)pk   (v h)k    (Return vector with head removed)ss
    nl (I H)pk (v h)k    (Return last element of vector)ss
    nl (H)pk   (v h)k    (Return vector with last element removed)ss
    small-vs

    nl         (v r)k    (Extract §Vnth§0 row/element of matrix/vector )ss ((n is 1-based!))s=c
    nlp     (<) (0)pfx       (Return matrix/vector with §Vnth§0 element removed)s=p
    nlp     (=) (0)pfx       [(Extract diagonal values ) {((of a matrix))s=c}]s=p
    nl (C-u)pk (v r)k    (Use §Vx§0 as preÎx. May be an integer, vector, or interval.)ss
    nl         (v c)k    (Like §Kv r§0, but acts column-wise instead of row-wise)ss

    sect-vs
} def

/vector-ops
{
    (Vector operations) head

    nl         (v l)k    (Length of vector)ss
    nl  (H)pk  (v l)k    (Dimensions of vector, matrix, etc)ss
    nl         (v t)k    (Transpose matrix)ss
    nl         (v v)k    (Reverse vector)ss
    nl         (v a)k    (Rearrange matrix to have §VpreÎx§0 columns)ss
    small-vs

    nl         (V S)k    (Sort vector elements)ss
    nl  (I)pk  (V S)k    (Sort, descending order)ss
    nl         (V G)k    (Grade: produce sorting-index vector)ss
    nl  (I)pk  (V G)k    (Grade, descending order)ss
    nl         (v f)k    [(Find ) [FC((1-based))] ( index of value §Vx§0 in vector §Vy)]ss
    nl         (V H)k    (Histogram; §VpreÎx§0 is number of bins)ss
    small-vs

    nl         (V C)k    (Cross-product of two 1x3 vectors)ss
    nl         (*)k      (Dot-product of two vectors, or matrix multiplication)ss
    nl         (V T)k    (Matrix trace )ss ((diagonal elements))s=c
    small-vs
    nl         (&)k      (Matrix inverse)ss
    nl         (V D)k    (Determinant of (square) matrix)ss
    nl         (V J)k    (Complex conjugate transposition of matrix)ss
    nl         (A)k      (Matrix norm (Frobenius norm))ss

    sect-vs
} def

/linear-algebra
{
    (Linear algebra) head

    nl         (&)k      (Matrix inverse)ss
    nl         (V D)k    (Determinant of (square) matrix)ss
    nl         (A)k      (Matrix norm (Frobenius norm))ss
    nl         (v n)k    (InÎnity-norm of vector, or row-norm of matrix)ss
    nl         (V N)k    (One-norm of vector, or column-norm of matrix)ss
    nl         (V L)k    (LU-decomposition of matrix)ss
    nl         (V K)k    (Kronecker product of two matrices)ss
    sect-vs
}def

/vectors-as-sets
{
    (Vectors as sets) head

    nl         (V #)k    (Count number of integers in a set)ss
    nl         (V +)k    (Remove dups )ss   ((usually unnecessary; implicit in other set operations))s=c
    nl         (V V)k    (Set union)ss
    nl         (V ^)k    (Set intersection)ss
    nl         (V -)k    (Set difference)ss
    nl         (V X)k    (XOR two sets)ss
    nl         (V ~)k    (Complement set )ss ((wrt real numbers))s=c
    nl         (V F)k    (Convert set to integers)ss
    nl         (V E)k    (Enumerate set; expand intervals )ss ((integer sets only))s=c
    nl         (V :)k    (Convert set into an interval form that spans it)ss

    nl         (a {)k    (Boolean: Is §Vy§0 in the set §Vx§0? )ss ((also works if §Vx§0 is an interval))s=c
    sect-vs
} def

/vector-packing
{
    (Vector packing/unpacking) head
    1 dict begin
    /xpvr xpvR def   % adjust spacing on right-justified numbers

    nl         (V p)k   (Pack vector from stack elements)ss
    nl         (V u)k   (Unpack vector into stack elements)ss
    nlp (>)   (0)pfx-r  (Pack §Vn§0 stack elements into a vector of length §Vn)s=p
    nlp (=)  (­1)pfx-r  [(Rectangular complex number: ) {/tx1 CX store} (§Vy§0 + §Vx§Ki)]s=p
    nlp (=)  (­2)pfx-r  [(Polar complex number:)        {tx1 x=}        (§Vr = y§0, §Gt§V = x)]s=p
    nlp (=)  (­3)pfx-r  [(HMS time form:)               {tx1 x=}        (§Vz§0 hours, §Vy§0 minutes, §Vx§0 seconds)]s=p
    nlp (=)  (­4)pfx-r  [(Error form: )                 {tx1 x=}        (§Vy§0 §M±§0 §Vx)]s=p
    nlp (=)  (­5)pfx-r  [(Modulo form:)                 {tx1 x=}        (§Vy§0 mod §Vx)]s=p
    nlp (=)  (­6)pfx-r  [(Interval form:)               {tx1 x=}        (§K[§Vy§0 .. §Vx§K])]s=p
    nlp (=)  (­7)pfx-r  [(Interval form:)               {tx1 x=}        (§K[§Vy§0 .. §Vx§K\))]s=p
    nlp (=)  (­8)pfx-r  [(Interval form:)               {tx1 x=}        (§K\(§Vy§0 .. §Vx§K])]s=p
    nlp (=)  (­9)pfx-r  [(Interval form:)               {tx1 x=}        (§K\(§Vy§0 .. §Vx§K\))]s=p
    nlp (=) (­10)pfx-r  [(Fraction:)                    {tx1 x=}        {(§Vy) (§Vx) a-over-b}]s=p
    nlp (=) (­11)pfx-r  [(Floating-point exponential:)  {tx1 x=}        (§Vy§M * 10) FVS(x)]s=p
    nlp (=) (­12)pfx-r  (same as ­11, but mantissa is Êoating-point)s=c
    nlp (=) (­13)pfx-r  (Real number converted to/from date form)s=p
    nlp (=) (­14)pfx-r  [(Date form:)                   {tx1 x=}        (§Vz§0 years §Vy§0 month §Vx§0 day)]s=p
    nlp (=) (­15)pfx-r  (Six values to date/time: year, month, day, hour, minute, second)s=p

    end
    sect-vs
} def

/mapping
{
    (Vector mapping/reduction) head

    nl         (V M)k    (Map a function across one or more vectors )ss  ((one for each function argument))s=c
    nl         (V M :)k  (Map by columns )ss ((of a matrix))s=c
    nl         (V M _)k  (Map by rows )ss ((of a matrix))s=c
    small-vs

    nl         (V R)k    (Reduce a vector, by applying a binary function repeatedly)ss
    nl  (I)pk  (V R)k    (Reduce, applying function from right-to-left)ss
    nl         (V R :)k  (Reduce by columns )ss ((of a matrix))s=c
    nl         (V R _)k  (Reduce by rows )ss ((of a matrix))s=c
    nl         (V U)k    (Reduce, accumulating intermediate values)ss
    nl  (I)pk  (V U)k    (Reduce, right-to-left, accumulating values)ss
    small-vs

    nl         (V O)k    (Generalized outer product )ss ((two vectors, one function §M»§0 matrix))s=c
    nl         (V I)k    (Generalized inner product )ss ((two vectors, two functions §M»§0 vector))s=c
    small-vs

    nl         (V A)k    (Apply a function to a vector¯use the vector elements as function arguments)ss
    sect-vs
} def

/symbolic-algebra
{
    (Algebraic (symbolic) manipulation) head
    nlc(Notes: Enter algebraic expressions with §K´§0 (apostrophe). Edit algebraic expressions with §K`§0 (backtick).)s=c
    nlc(Enter systems of related equations as vectors of equations.)s=c
    
    nl         (a S)k  (Solve equation/inequality/system for speciÎed variable)ss
    nl  (H)pk  (a S)k  (Solve, reporting general family of solutions  )ss  (Manual: 10.6.1 «Multiple Solutions»)s=c
    nlct               (§Vs1§0, §Vs2§0, etc. represent signs)s=c
    nlct               (§Vn1§0, §Vn2§0, etc. represent integers)s=c
    small-vs
    nl         (a l)k  (Evaluate expression, Îrst setting a variable temporarily)ss
    nl         (a c)k  (Collect terms involving a speciÎed variable)ss
    nl         (a x)k  (Expand expression )ss ((by applying distributive law))s=c
    nl         (a n)k  (Arrange formula into quotient of polynomials)ss
    nl         (a a)k  (Expand rational polynomial by partial fractions)ss
    small-vs
    nl         (a R)k  (Find root of equation in §Vy§0; §Vx§0 is initial guess  )ss  (Manual: 10.7.1 «Root Finding»)s=c
    nl         xt x=   (Returns §V[root, error])ss
    small-vs
    nl         (a N)k  (Find local minimum of equation in §Vy§0; §Vx§0 is initial guess)ss
    nl         (a X)k  (Find local maximum of equation in §Vy§0; §Vx§0 is initial guess)ss
    nl         xt x=   (Returns §V[root, min/max value])ss
    small-vs

    sect-vs
} def

/summations
{
    (Summations) head

    nl         (a +)k  (Sum formula \(in §Vx§0\), prompting for index bounds)ss
    nl         (a ­)k  (Same, but alternating sum)ss
    nl         (a *)k  (Product formula in §Vx)ss
    nl         (a T)k  (Evaluate formula over range of inputs, returning vector of results)ss

    sect-vs
} def

/calculus
{
    (Calculus) head

    nl         (a d)k  (Compute derivative of expression)ss
    nl  (H)pk  (a d)k  (Ditto; does not assume other variables are constant)ss
    nl         (a i)k  (IndeÎnite integral)ss
    nl (C-u)pk (a i)k  (DeÎnite integral; prompts for bounds)ss
    nl         (a I)k  (Numeric integration)ss

    sect-vs
} def

/note-num
{
    xn  fsH  x=y-
    s-rshow
    xt x=
} def
/note-nl
{
    xt fsT x=y-
} def

/user-notes
{
    % Display a heading, but don't add it to the index
    1 dict begin    (Notes) head    end

    f=t
    4 dict begin
    /xn  lx (19.) stringwidth pop add  def
    /xt  xn ( )   stringwidth pop add  def

    nlc (For everbody:)show
%   f=d (    textleft = ) show  xt 20 string cvs show
    f=t
    (1.) note-num
    (The term §I«pfx»§0 or §I«preÎx»§0 means the Emacs preÎx argument. This guide sometimes)show
    note-nl
    (refers to it as §In§0 or §Inth§0.)show
    (2.) note-num
    (The top of the stack is called §Vx§0. The second stack position is §Vy§0; the third is §Vz§0. Algebraic)show
    note-nl
    (formulas can refer to these as §V$, $$, $$$§0 (etc), or §V$1, $2, $3§0 (etc).)show

    small-vs
    small-vs

    nlc (For Emacs newbies:)show
    f=t
    (1.) note-num
    (Most keys in this guide are typed as you see them: §Kj§0 means to type a lowercase j.)show
    (2.) note-num
    (Most calc commands require multiple keystrokes. Type the keys sequentially, with)show
    note-nl
    (no spaces in between.)show
    (3.) note-num
    (The notation «§KC-§0» means to press the Ctrl key with another key; e.g., §KC-j§0 means)show
    note-nl
    («control j».)show
    (4.) note-num
    (The notation «§KM-§0» means to press the Meta key with another key. Most modern key-)show
    note-nl
    (boards do not have a Meta key, but you can generally use the Alt key.)show
    (5.) note-num
    (§KRET§0 means the «return» or «enter» key; §KDEL§0 means the delete key; §KTAB§0 means the)show
    note-nl
    (tab key.)show
    (6.) note-num
    (The §I«preÎx argument»§0 is a number that you can use to modify certain commands.)show
    note-nl
    (To specify it, type §KC-u§0, type the number, then type the command as usual.)show
    (7.) note-num
    (§ICopy§0 is §KM-k§0; §Icut§0 is §KC-k§0; §Ipaste§0 is §KC-y§0. They just are.)show

    sect-vs
    end
} def

/show-doc-title
{
    FF setfont
    doc-title type
    [
        /stringtype
        {
            cx cy moveto
            s-cshow
        }

        /arraytype
        {
            pop
            % Move up from the center by half the number of array elements
            cx cy
            doc-title length 1 sub 2 idiv
            fsF mul add
            moveto

            doc-title
            {
                s-cshow
                cx fsF x=y-
            } forall
        }

    ]cond
} def


%%%-------------------------------------------------------------------------------------
%%% Page definitions

/font-test-page
{
    lx ty M
    font-test-section
    showpage
} def

/front-cover
{
    /page-label () def
    show-doc-title

    FPN setfont
    rx by moveto
    [{/tx1 CX store}   (Last updated: ) doc-date] s-rshow
    tx1 x=  fsN y+  [(Version: ) doc-version] s-show

    showpage

}def

/page1
{
    /page-label (1) def
    lx ty M
    data-entry
    stack-ops
    meta-ops
    showpage
} def

/page2
{
    /page-label (2) def
    lx ty moveto
    display-modes
    killing-etc
    rounding
    showpage
} def

/page3
{
    /page-label (3) def
    lx ty moveto
    general-math
    algebraic-ops
    trigonometry
    complex-numbers
    showpage
} def

/page4
{
    /page-label (4) def
    lx ty moveto
    percentages
    combinatorics
    random-numbers
    conversions
    binary
    showpage
} def

/page5
{
    /page-label (5) def
    lx ty moveto
    date-time
    showpage
} def

/page6
{
    /page-label (6) def
    lx ty moveto
    storing-recalling
    stack-trail
    showpage
} def

/page7
{
    /page-label (7) def
    lx ty moveto

    vector-building
    vector-extraction
    vectors-as-sets
    vector-packing
    showpage
} def

/page8
{
    /page-label (8) def
    lx ty moveto

    vector-ops
    mapping
    ejr? not {linear-algebra} if
    showpage
} def

/page9
{
    /page-label (9) def
    lx ty moveto

    symbolic-algebra
    summations
    calculus
    units
    showpage
} def

/page10
{
    /page-label (10) def
    lx ty moveto

    programming
    logical
    flow-control
    showpage
} def

/blank-page
{
    /page-label () def
    showpage
}def

% Display one index entry at vertical position <y>
%--->    [(label)  (pgnum)]   <one-ix>   --
/one-ix
{
    fsH y-       % drop down

    % draw dots
    tx1 x=
    {
        CX tx2 ge {exit} if
        (. ) show
    } loop

    aload pop    % (section name)   (page num)
    tx3 x= s-rshow   % show page num

    % show section name
    lx x=
    dup s-bounds gsave 1 setgray rect fill grestore
    s-show
}def

/index-section
{
    % Display a heading, but don't add it to the index
    1 dict begin    (Index) head    end
    
    % Find longest, shortest strings
    FT setfont
    /tx1 999 store
    /tx2   0 store
    index-entries
    {
        0 get s-width
        dup tx1 lt {/tx1 1 index store} if
        dup tx2 gt {/tx2 1 index store} if
        pop
    } forall

    % convert to x-positions
    % tx1 = left side of section name
    % tx2 = end of dots
    % tx3 = right side of page number
    /tx1 tx1 lx add store
    /tx2 tx2 lx add 30 add store
    /tx3 tx2 (99) stringwidth pop add store

    % Sort the list
    /index-entries  index-entries {index-cmp} bubble-sort  store

    4 dict begin
    /cnt  index-entries length def
    /c1   cnt 1 add 2 idiv def
    /c2   cnt c1 sub def
    /ty1  CY def
    % Display the first half in one column
    index-entries  0 c1 getinterval
    {one-ix} forall
    % Display the second half in a second column
    gsave
    ty1 y=
    cx lx sub 0 translate
    index-entries  c1 c2 getinterval
    {one-ix} forall
    grestore
    end

    sect-vs
} def

/index-page
{
    /page-label () def
    lx ty moveto

    index-section
    user-notes
    copyright-notice
    showpage
} def
/index-cmp
{
    1 index 0 get
    1 index 0 get
    2 copy lt
    {
        4 {pop} repeat
        true
    }
    {
        eq
        {
            1 get exch 1 get exch
            lt
        }
        {pop pop false}
        ifelse
    }
    ifelse
} def


%%%-------------------------------------------------------------------------------------
%%% Output

/eopp-backside?  false def

/end-of-physical-page
{
    Nup 4 eq
    {
        eopp-backside?
        {
            <<
                /xdiv   PPW 2 div
                /ydiv   PPH 6 div
            >> begin
            0 setlinewidth
    
            % Staple marks
            newpath
            xdiv  ydiv        M  0  -36  RL
            xdiv  ydiv 2 mul  M  0   36  RL
            xdiv  ydiv 4 mul  M  0  -36  RL
            xdiv  ydiv 5 mul  M  0   36  RL
            stroke
    
            % Additional vertical registration marks
            xdiv  0    M    0   20  RL
            xdiv  PPH  M    0  -20  RL
            stroke
    
            % Horizontal "cut here" line
            PPW  PPH 2 div dup 0 exch M L stroke
            end
        } if
    } if

    /eopp-backside? eopp-backside? not def
} def

% booklet style!
Nup
[

    1
    {
        pop
        % front-cover
        % page1
        % page2
        % page3
        % page4
        % page5
        % page6
        % page7
        % page8
        % page9
        % page10
        index-page
    }

    2
    {
        pop
        page5 page6
        page7 page4

        page3 page8
        page9 page2

        page1 page10
        index-page front-cover
    }
    4
    {
        pop
        page3 page8
        page5 page6
        page9 page2
        page7 page4

        page1 page10
        blank-page blank-page
        index-page front-cover
        blank-page blank-page
    }
]cond
